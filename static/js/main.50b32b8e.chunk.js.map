{"version":3,"sources":["Node.js","animations.js","helpers/gridPropertiesHelper.js","helpers/initialGridHelper.js","structures/queue.js","algorithms/bfs.js","structures/stack.js","algorithms/dfs.js","structures/heap.js","algorithms/dijkstra.js","algorithms/best-first-search.js","algorithms/a.js","NavStyles.js","Nav.js","hooks/useToggleState.js","PathFindingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","id","val","className","onMouseDown","row","col","onMouseEnter","onMouseUp","isWeighted","w","sleep","m","Promise","r","setTimeout","pathAnimation","path","a","i","length","changingPropAnimation","visitedAnimation","start","end","color","document","getElementById","style","backgroundColor","wallAnimation","v","isStart","isFinish","startNodeAnimation","finishNodeAnimation","clearNodeAnimation","manhattan","b","c","d","Math","abs","valToIndx","nCols","floor","getNewGridWithNewProperty","grid","prop","newGrid","slice","oldNode","oldPropToggled","toggleNodeProperty","node","newNode","getNewGridWithWallToggled","isWall","getNewMazedGrid","eps","random","getPath","parents","dist","push","console","log","reverse","getWeightedPath","getRowsCols","width","window","innerWidth","documentElement","clientWidth","body","height","innerHeight","clientHeight","getRandomVertex","nRows","createNode","finish","adjList","createAdjList","getInitialGrid","wRange","currentRow","this","next","Queue","first","last","size","removed","bfs","visited","q","enQueue","deQueue","key","wVertex","Stack","dfs","result","stack","pop","Heap","values","idxs","undefined","k","j","idx","l","smallIdx","lessThan","contains","parentIdx","myParentIdx","bubbleUp","newVal","element","heap","min","myChildrenIdx","lChild","rChild","bubbleDown","dijkstra","distances","Array","fill","Infinity","inspectedNodes","nDeq","enqueue","s","dequeue","smallestVal","found","smallest","neighbour","nextVertex","decreaseKey","bestFirstSearch","realDistance","alpha","f","newF","oldF","getPathDistance","distance","styles","theme","Navbar","display","alignItems","justifyContent","marginBottom","title","button","margin","cursor","border","fontSize","withStyles","classes","disable","setGrid","setDisable","setIsWeighted","toggleIsweighted","clear","startVal","finishVal","clearAnimation","n","newMaze","handleClick","alg","rowEnd","colEnd","rowStart","colStart","AppBar","position","Toolbar","Typography","variant","onClick","disabled","vertex","clearPathAnimation","bestFisrtSearch","open","useToggleState","initialVal","useState","state","setState","toggle","PathFindingVisualizer","setNRows","setNCols","startVertex","setStarteVertex","finishVertex","setFinishVertex","mouseIsPressed","setMouseIsPressed","createWall","setCreatWall","toggleCreateWall","changeStart","setChangeStart","toggleChangeStart","changeFinish","setChangeFinish","toggleChangeFinish","useEffect","initialGrid","handleMouseDown","getNewGridWitNewStart","getNewGridWitNewFinish","handleMouseEnter","handleMouseUp","onKeyDown","event","tabIndex","map","rowIdx","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.50b32b8e.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.css';\n\nexport default function Node(props) {\n  return (\n    <div\n      id={`node-${props.val}`}\n      className={'node'}\n      onMouseDown={() => props.onMouseDown(props.row, props.col)}\n      onMouseEnter={() => props.onMouseEnter(props.row, props.col)}\n      onMouseUp={() => props.onMouseUp()}\n    >\n      {props.isWeighted ? <span>{props.w}</span> : ''}\n    </div>\n  );\n}\n","export const sleep = (m) => new Promise((r) => setTimeout(r, m));\n\nexport const pathAnimation = async (path) => {\n  for (let i = 0; i < path.length; i++) {\n    await sleep(12);\n    changingPropAnimation(path[i], 'yellow');\n  }\n};\n\nexport const visitedAnimation = async (val, start, end) => {\n  if (val === end) return;\n  if (val === start) return;\n  await sleep(7);\n  changingPropAnimation(val, 'blue');\n};\n\nexport const clearAnimation = (grid, startVal, finishVal) => {\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const v = grid[i][j];\n      changingPropAnimation(v.val, 'white');\n      if (v.val === startVal) {\n        changingPropAnimation(v.val, 'green');\n      }\n      if (v.val === finishVal) {\n        changingPropAnimation(v.val, 'red');\n      }\n    }\n  }\n};\n\nconst changingPropAnimation = (val, color) => {\n  const vertex = document.getElementById(`node-${val}`).style;\n  vertex.backgroundColor = `${color}`;\n};\n\nexport const wallAnimation = async (v) => {\n  if (v.isStart || v.isFinish) return;\n  await sleep(1);\n  changingPropAnimation(v.val, 'black');\n};\n\nexport const startNodeAnimation = (val) => {\n  changingPropAnimation(val, 'green');\n};\n\nexport const finishNodeAnimation = (val) => {\n  changingPropAnimation(val, 'red');\n};\n\nexport const clearNodeAnimation = (val) => {\n  changingPropAnimation(val, 'white');\n};\n\nexport const clearPathAnimation = (grid) => {\n  let vertex;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const v = grid[i][j];\n      vertex = document.getElementById(`node-${v.val}`).style;\n      if (\n        vertex.backgroundColor === 'blue' ||\n        vertex.backgroundColor === 'yellow'\n      ) {\n        clearNodeAnimation(v.val, 'white');\n      }\n    }\n  }\n};\n","import { wallAnimation } from '../animations';\n\n// Node Helpers\n\nexport const manhattan = (a, b, c, d) => {\n  return Math.abs(a - b) + Math.abs(c - d);\n};\n\n// returns {row, col} of a vertex val\nexport const valToIndx = (val, nCols) => {\n  const row = Math.floor(val / nCols);\n  const col = val - row * nCols;\n  return [row, col];\n};\n\n// Grid Helpers\n\nconst getNewGridWithNewProperty = (grid, row, col, prop, val, nCols) => {\n  const newGrid = grid.slice();\n  const [r, c] = valToIndx(val, nCols);\n  const oldNode = newGrid[r][c];\n  const oldPropToggled = toggleNodeProperty(oldNode, prop, false);\n  newGrid[r][c] = oldPropToggled;\n  const node = newGrid[row][col];\n  const newNode = toggleNodeProperty(node, prop, true);\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (wall is created)\nexport const getNewGridWithWallToggled = (grid, row, col) => {\n  if (grid[row][col].isStart || grid[row][col].isFinish) return grid;\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = toggleNodeProperty(node, 'isWall', !node.isWall);\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (new start node)\nexport const getNewGridWitNewStart = (grid, row, col, startVal, nCols) => {\n  const newGrid = getNewGridWithNewProperty(\n    grid,\n    row,\n    col,\n    'isStart',\n    startVal,\n    nCols\n  );\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (new finish point)\nexport const getNewGridWitNewFinish = (grid, row, col, finishVal, nCols) => {\n  const newGrid = getNewGridWithNewProperty(\n    grid,\n    row,\n    col,\n    'isFinish',\n    finishVal,\n    nCols\n  );\n  return newGrid;\n};\n\n// returns a new mazed grid\n// a node has eps prob to become a wall\nexport const getNewMazedGrid = async (grid, eps) => {\n  let newGrid = grid.slice();\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      if (grid[row][col].isStart || grid[row][col].isFinish) {\n        break;\n      }\n      if (Math.random() <= eps) {\n        const node = newGrid[row][col];\n        const newNode = toggleNodeProperty(node, 'isWall', true);\n        newGrid[row][col] = newNode;\n        await wallAnimation(newGrid[row][col]);\n      }\n    }\n  }\n  return newGrid;\n};\n\nconst toggleNodeProperty = (node, prop, val) => {\n  const newNode = {\n    ...node,\n    [prop]: val,\n  };\n  return newNode;\n};\n\n//   building path\nexport const getPath = (parents, end, dist) => {\n  let a = parents[end];\n  let path = [];\n  for (let i = 0; i < dist - 1; i++) {\n    path.push(a);\n    a = parents[a];\n  }\n  console.log(`Min Path: ${path.length + 1} squares`);\n  return path.reverse();\n};\n\n//   building path\nexport const getWeightedPath = (parents, start, end) => {\n  let a = parents[end];\n  let path = [];\n  while (a !== start) {\n    path.push(a);\n    a = parents[a];\n  }\n  return path.reverse();\n};\n\n// return number of rows and cols to display in this screen\nexport const getRowsCols = () => {\n  const width =\n    window.innerWidth ||\n    document.documentElement.clientWidth ||\n    document.body.clientWidth;\n  const height =\n    window.innerHeight ||\n    document.documentElement.clientHeight ||\n    document.body.clientHeight;\n  const nRows = Math.floor(width / 60);\n  const nCols = Math.floor(height / 15);\n  return [nRows, nCols];\n};\n","// import { NUM_COL, NUM_ROW } from '../consts';\n\n// returns a random vertex value\nexport const getRandomVertex = (nRows, nCols) => {\n  return Math.floor(Math.random() * nRows * nCols);\n};\n\nconst createNode = (col, row, start, finish, nRows, nCols, w = 1) => {\n  const val = row * nCols + col;\n  const adjList = createAdjList(val, col, row, nRows, nCols);\n\n  return {\n    col,\n    row,\n    isStart: val === start,\n    isFinish: val === finish,\n    isWall: false,\n    adjList: adjList,\n    val: val,\n    w,\n  };\n};\n\n//         A\n//    B   VAL  D\n//         C\n// returns all neighbours of VAL\nconst createAdjList = (val, col, row, nRows, nCols) => {\n  //   neighbours in a line above\n  // negative numbers arent a node\n  const a = row !== 0 ? val - nCols : null;\n  // neighbours in the same line\n  // check left border\n  const b = col !== 0 ? val - 1 : null;\n  // check right border\n  const d = col !== nCols - 1 ? val + 1 : null;\n  //  neighbours in a line bellow\n  // check overflow\n  const c = row !== nRows - 1 ? val + nCols : null;\n\n  return { a, b, c, d };\n};\n\n// returns the initial Grid\nexport const getInitialGrid = (start, finish, nRows, nCols, wRange = 0) => {\n  const grid = [];\n  for (let row = 0; row < nRows; row++) {\n    const currentRow = [];\n    for (let col = 0; col < nCols; col++) {\n      // get random weight for all edges of this node\n      const w = Math.floor(Math.random() * wRange + 1);\n      currentRow.push(createNode(col, row, start, finish, nRows, nCols, w));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n","// linked list Node\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n// Queue implementation, FIFO, through linked list\nclass Queue {\n  constructor() {\n    this.first = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  // add to the end and return the size of this queue\n  enQueue(val) {\n    let node = new Node(val);\n    if (this.size === 0) {\n      this.first = node;\n      this.last = node;\n    } else {\n      this.last.next = node;\n      this.last = node;\n    }\n    this.size++;\n    return this.size;\n  }\n\n  // remove the first node and return it\n  deQueue() {\n    if (this.size === 0) return null;\n    let removed = this.first;\n    if (this.size === 1) {\n      this.first = null;\n      this.last = null;\n    } else {\n      this.first = removed.next;\n      removed.next = null;\n    }\n    this.size--;\n    return removed;\n  }\n}\n\nexport default Queue;\n","import Queue from '../structures/queue';\nimport { valToIndx, getPath } from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst bfs = async (grid, start, end, nCols) => {\n  let visited = {};\n  let parents = {};\n  let dist = {};\n  let q = new Queue();\n  // add start vertex to the queue\n  q.enQueue(start);\n  // start vertex is already visited\n  visited[start.val] = true;\n  dist[start.val] = 0;\n  parents[start.val] = null;\n  // vertex that will be deQueue\n  let v;\n  while (q.size !== 0) {\n    v = q.deQueue().val;\n    // check if v is the end vertex\n    if (v.val === end.val) {\n      //   we find the target\n      break;\n    }\n    // for every edge of v\n    for (const key in v.adjList) {\n      const w = v.adjList[key];\n      const [row, col] = valToIndx(w, nCols);\n      //   wVertex has all properties while w is wVeterx.val\n      const wVertex = grid[row][col];\n      //   check w is visited, is not null or wall\n      if (visited[w] !== true && w !== null && !wVertex.isWall) {\n        //mark  w as visited\n        visited[w] = true;\n        await visitedAnimation(w, start.val, end.val);\n        //   enQueue vertex w\n        q.enQueue(wVertex);\n        parents[w] = v.val;\n        dist[w] = dist[v.val] + 1;\n      }\n    }\n  }\n  const path = getPath(parents, end.val, dist[end.val]);\n  await pathAnimation(path, start.val);\n};\n\nexport default bfs;\n","// linked list Node\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n// simple implementation using SLL, shift and unshift, here called as push and pop\n// First in Last Out\nclass Stack {\n  constructor() {\n    this.first = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  // add a node at the beginning and return the size of this stack\n  push(val) {\n    let node = new Node(val);\n    if (this.size === 0) {\n      this.first = node;\n      this.last = node;\n    } else {\n      node.next = this.first;\n      this.first = node;\n    }\n    this.size++;\n    return this.size;\n  }\n  // remove the first node and return it\n  pop() {\n    // empty stack\n    if (this.size === 0) return null;\n    let removed = this.first;\n    if (this.size === 1) {\n      this.first = null;\n      this.last = null;\n    } else {\n      this.first = removed.next;\n      removed.next = null;\n    }\n    this.size--;\n    return removed;\n  }\n}\n\nexport default Stack;\n","import Stack from '../structures/stack';\nimport { valToIndx } from '../helpers/gridPropertiesHelper';\nimport { visitedAnimation } from '../animations';\n\nconst dfs = async (grid, start, end, nCols) => {\n  //   const end = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n  //   stack pop order\n  let result = [];\n  let visited = {};\n  let stack = new Stack();\n  // add start vertex to the stack\n  stack.push(start);\n  // start vertex is already visited\n  visited[start.val] = true;\n  let v;\n  while (stack.size !== 0) {\n    // take vertex v from the top of the stack\n    v = stack.pop().val;\n    result.push(v.val);\n    if (v.val === end.val) {\n      //   we find the target\n      break;\n    }\n    // mark w as visited\n    visited[v.val] = true;\n    await visitedAnimation(v.val, start.val, end.val);\n    // for every edge of v\n    for (const key in v.adjList) {\n      const w = v.adjList[key];\n      const [row, col] = valToIndx(w, nCols);\n      //   wVertex has all properties while w is wVeterx.val\n      const wVertex = grid[row][col];\n      //   check w is visited, is not null or wall\n      if (visited[w] !== true && w !== null && !wVertex.isWall) {\n        //   push w vertex\n        stack.push(wVertex);\n        if (w === end.val) {\n          //   we find the target\n          break;\n        }\n      }\n    }\n  }\n};\n\nexport default dfs;\n","class Node {\n  constructor(key, val) {\n    this.key = key;\n    this.val = val;\n  }\n}\n\nclass Heap {\n  constructor() {\n    this.values = [];\n    // dict: key to array idx => you say the key it returns the idx\n    this.idxs = {};\n  }\n\n  //   return true if this heap constains this key\n  //   otherwise returns false\n  contains(key) {\n    if (this.values[this.idxs[key]] === undefined) return false;\n    return true;\n  }\n\n  // return true if the element from index i is smaller than k idx element\n  lessThan(i, k) {\n    // out of bounds\n    if (i < 0 || k < 0) return false;\n    if (i > this.values.length - 1 || k > this.values.length - 1) return false;\n    let val = this.values[i].val;\n    let parent = this.values[k].val;\n    if (val < parent) return true;\n    return false;\n  }\n\n  //   return the parent's index of the ith node\n  myParentIdx(i) {\n    return Math.floor((i - 1) / 2);\n  }\n\n  //   return the children's index of the ith node\n  myChildrenIdx(i) {\n    // left 2 * i + 1 , right 2 * idx + 2\n    return [2 * i + 1, 2 * i + 2];\n  }\n\n  bubbleUp(i, j) {\n    //swap i and j\n    [this.values[i], this.values[j]] = [this.values[j], this.values[i]];\n\n    // swap idxs elements in dict key to idx\n    [this.idxs[this.values[i].key], this.idxs[this.values[j].key]] = [\n      this.idxs[this.values[j].key],\n      this.idxs[this.values[i].key],\n    ];\n  }\n\n  //   also returns the smmaller child idx\n  bubbleDown(idx, l, r) {\n    let smallIdx;\n    if (this.lessThan(l, r)) {\n      smallIdx = l;\n    } else if (this.lessThan(r, l)) {\n      smallIdx = r;\n    } else {\n      smallIdx = l;\n    }\n    // swap element from idx with greater\n    [this.values[idx], this.values[smallIdx]] = [\n      this.values[smallIdx],\n      this.values[idx],\n    ];\n\n    // swap idxs elements in dict key to idx\n    [this.idxs[this.values[idx].key], this.idxs[this.values[smallIdx].key]] = [\n      this.idxs[this.values[smallIdx].key],\n      this.idxs[this.values[idx].key],\n    ];\n\n    return smallIdx;\n  }\n\n  // insert an element in the next free spot and rearrange\n  //   return Heap\n  enqueue(key, val) {\n    // check whether this val belongs to this heap\n    // to avoid duplicate keys\n    if (this.contains(key)) return false;\n    let node = new Node(key, val);\n    this.values.push(node);\n    // last position to insert this new node\n    let idx = this.values.length - 1;\n    // add the idx of this key on the dict\n    this.idxs[key] = idx;\n    let parentIdx = this.myParentIdx(idx);\n    // bubble-up (while this new node is smaller than its parent)\n    while (this.lessThan(idx, parentIdx)) {\n      this.bubbleUp(idx, parentIdx);\n      //   recalculate node idx, parent idx position\n      idx = parentIdx;\n      parentIdx = this.myParentIdx(idx);\n    }\n    return this;\n  }\n\n  //   update val of this key and return this heap\n  //   if there is not any node with this key in this heap return false\n  decreaseKey(key, newVal) {\n    // check whether this key belongs to this heap\n    if (!this.contains(key)) return false;\n    //   get idx of this key\n    let idx = this.idxs[key];\n    //   update node with new val\n    this.values[idx].val = newVal;\n    let parentIdx = this.myParentIdx(idx);\n    if (parentIdx < 0) return this;\n    // bubble-up (while this new node is smaller than its parent)\n    while (this.lessThan(idx, parentIdx)) {\n      this.bubbleUp(idx, parentIdx);\n      //   recalculate node idx, parent idx position\n      idx = parentIdx;\n      parentIdx = this.myParentIdx(idx);\n    }\n    return this;\n  }\n\n  // Remove the root (min),\n  //   put the last element in the top and then rearrange\n  // return the root and the new arrangement\n  dequeue() {\n    // if is empty return undefined\n    if (this.values.length === 0) return undefined;\n    if (this.values.length === 1)\n      return { element: this.values.pop(), heap: this };\n    const min = this.values[0];\n    // replace the root with the last element\n    this.values[0] = this.values.pop();\n    // delete from dict\n    delete this.idxs[min.key];\n    // update idx of the 'new root' in the dict\n    this.idxs[this.values[0].key] = 0;\n    // index of this node we have to rearrange and the idx of its children\n    let idx = 0;\n    let [lChild, rChild] = this.myChildrenIdx(idx);\n    // bubble-down (while any child is smaller than the parent)\n    while (this.lessThan(lChild, idx) || this.lessThan(rChild, idx)) {\n      // update idx and its children\n      idx = this.bubbleDown(idx, lChild, rChild);\n      [lChild, rChild] = this.myChildrenIdx(idx);\n    }\n    return { element: min, heap: this };\n  }\n}\n\nexport default Heap;\n","import Heap from '../structures/heap';\nimport { valToIndx, getWeightedPath } from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst dijkstra = async (grid, start, end, nCols) => {\n  const heap = new Heap();\n  // Initialize distances with Infinity and parents array with null\n  // Distance between any given node to the start node\n  const distances = Array(grid.length * nCols).fill(Infinity);\n  const parents = Array(grid.length * nCols).fill(null);\n  let smallestVal, found;\n  let inspectedNodes = 0;\n  let nDeq = 0;\n  let decrease = false;\n  distances[start.val] = 0;\n  //   add the start node to the heap\n  heap.enqueue(start.val, 0);\n\n  //   while there are elements in this heap\n  while (heap.values.length) {\n    //   get the min value from the heap\n    let s = heap.dequeue().element;\n    nDeq++;\n\n    // get its vertex\n    smallestVal = s.key;\n    // check if we find the target node\n    if (smallestVal === end.val) {\n      found = true;\n      break;\n    }\n    // convert smallestVal to a Vertex\n    const [r, c] = valToIndx(smallestVal, nCols);\n    const smallest = grid[r][c];\n    // for all neighbour of smallest\n    for (let k in smallest.adjList) {\n      // get the val of the neighbour\n      const neighbour = smallest.adjList[k];\n      // check if is not null => grid border\n      if (neighbour !== null) {\n        const [row, col] = valToIndx(neighbour, nCols);\n        //   neighbour as a vertex\n        let nextVertex = grid[row][col];\n        // calculate Dijkstra's  Greedy Criterium\n        //   distance to smallest (IS short path to it) + smallest to nextVertex edge (W*)\n        // W* : weight of <smallest> edges, all edges from the same node have the same weight in this grid\n        let d = distances[smallestVal] + smallest.w;\n        //   compare distance calculated with last distance storaged\n        if (d < distances[nextVertex.val] && !nextVertex.isWall) {\n          //   updating distances and parents\n          distances[nextVertex.val] = d;\n          parents[nextVertex.val] = smallest.val;\n          decrease = heap.decreaseKey(nextVertex.val, d);\n          if (!decrease) {\n            // enqueue with new priority\n            heap.enqueue(nextVertex.val, d);\n          }\n          await visitedAnimation(nextVertex.val, start.val, end.val);\n          inspectedNodes++;\n        }\n      }\n    }\n  }\n  if (!found) return;\n  const path = getWeightedPath(parents, start.val, end.val);\n  console.log(`dijkstra Min Distance = ${distances[end.val]}`);\n  console.log(`dijkstra inspectedNodes = ${inspectedNodes}`);\n  console.log(`dijkstra dequeues = ${nDeq}`);\n  await pathAnimation(path, start.val);\n};\n\nexport default dijkstra;\n","import Heap from '../structures/heap';\nimport {\n  valToIndx,\n  getWeightedPath,\n  manhattan,\n} from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst bestFirstSearch = async (grid, start, end, nCols) => {\n  const heap = new Heap();\n  // Initialize parents array with null\n  const parents = Array(grid.length * nCols).fill(null);\n  //   the distance between start node and any given node\n  const realDistance = Array(grid.length * nCols).fill(0);\n  let smallestVal, found;\n  let inspectedNodes = 0;\n  let nDeq = 0;\n  let decrease = false;\n  // this time our heap val will be the manhattan distance to the target node\n  heap.enqueue(start.val, manhattan(start.row, end.row, start.col, end.col));\n\n  //   while there are elements in this heap\n  while (heap.values.length) {\n    //   get the min value from the heap\n    let s = heap.dequeue().element;\n    nDeq++;\n    // get its vertex\n    smallestVal = s.key;\n    // check if we find the target node\n    if (smallestVal === end.val) {\n      found = true;\n      break;\n    }\n    // convert smallestVal to a Vertex\n    const [r, c] = valToIndx(smallestVal, nCols);\n    const smallest = grid[r][c];\n    // for all neighbour of smallest\n    for (let k in smallest.adjList) {\n      // get the val of the neighbour\n      const neighbour = smallest.adjList[k];\n      // check if is not null => grid border\n      if (neighbour !== null) {\n        const [row, col] = valToIndx(neighbour, nCols);\n        //   neighbour as a vertex\n        let nextVertex = grid[row][col];\n        //   check if nextVertex is a valid node => not a wall and not visited => realDistance ===0\n        if (!nextVertex.isWall && realDistance[nextVertex.val] === 0) {\n          // calculate manhattan distance from nextVertex to the target node\n          let d = manhattan(row, end.row, col, end.col);\n          //   updating distances and parents\n          parents[nextVertex.val] = smallest.val;\n          // calculate real distance until this node from start node\n          realDistance[nextVertex.val] =\n            realDistance[smallest.val] + smallest.w;\n          decrease = heap.decreaseKey(nextVertex.val, d);\n          if (!decrease) {\n            // enqueue with new priority\n            heap.enqueue(nextVertex.val, d);\n          }\n          inspectedNodes++;\n          await visitedAnimation(nextVertex.val, start.val, end.val);\n        }\n      }\n    }\n  }\n  if (!found) return;\n  const path = getWeightedPath(parents, start.val, end.val);\n  //   distance of this path (yellow)\n  console.log(`bestFirstSearch Distance = ${realDistance[end.val]}`);\n  console.log(`bestFirstSearch inspectedNodes = ${inspectedNodes}`);\n  console.log(`bestFirstSearch dequeues = ${nDeq}`);\n  await pathAnimation(path, start.val);\n};\n\nexport default bestFirstSearch;\n","import Heap from '../structures/heap';\nimport {\n  valToIndx,\n  getWeightedPath,\n  manhattan,\n} from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst a = async (grid, start, end, nCols, alpha) => {\n  const heap = new Heap();\n  // Initialize distances with Infinity and parents array with null\n  // Distance between any given node to the start node\n  const distances = Array(grid.length * nCols).fill(Infinity);\n  const parents = Array(grid.length * nCols).fill(null);\n  let smallestVal, found;\n  let inspectedNodes = 0;\n  let decrease = false;\n  let nDeq = 0;\n  distances[start.val] = 0;\n  //   add the start node to the heap\n  //   we will use f(n) = alpha * distance + ( 1 - alpha) * Manhattan distance\n  // as val to be minimized in the heap\n  //   f for the start node\n  heap.enqueue(start.val, f(0, start, end, alpha));\n  inspectedNodes++;\n\n  //   while there are elements in this heap\n  while (heap.values.length) {\n    //   get the min value from the heap\n    let s = heap.dequeue().element;\n    nDeq++;\n    // get its vertex\n    smallestVal = s.key;\n    // check if we find the target node\n    if (smallestVal === end.val) {\n      found = true;\n      break;\n    }\n    // convert smallestVal to a Vertex\n    const [r, c] = valToIndx(smallestVal, nCols);\n    const smallest = grid[r][c];\n    // for all neighbour of smallest\n    for (let k in smallest.adjList) {\n      // get the val of the neighbour\n      const neighbour = smallest.adjList[k];\n      // check if is not null => grid border\n      if (neighbour !== null) {\n        const [row, col] = valToIndx(neighbour, nCols);\n        //   neighbour as a vertex\n        let nextVertex = grid[row][col];\n        // calculate Dijkstra's  Greedy Criterium and manhattan distance\n        let d = distances[smallestVal] + smallest.w;\n        let newF = f(d, nextVertex, end, alpha);\n        let oldF = f(distances[nextVertex.val], nextVertex, end, alpha);\n        //   compare f(d,next,end) with f calculated with last distance storaged\n        if (newF < oldF && !nextVertex.isWall) {\n          //   updating distances and parents\n          distances[nextVertex.val] = d;\n          parents[nextVertex.val] = smallest.val;\n          decrease = heap.decreaseKey(nextVertex.val, newF);\n          if (!decrease) {\n            // enqueue with new priority\n            heap.enqueue(nextVertex.val, newF);\n          }\n          await visitedAnimation(nextVertex.val, start.val, end.val);\n          inspectedNodes++;\n        }\n      }\n    }\n  }\n  if (!found) return;\n  const path = getWeightedPath(parents, start.val, end.val);\n  //   min distance g() found  by A*\n  console.log(`A* Min Distance = ${distances[end.val]}`);\n  //   distance of this path (yellow)\n  console.log(\n    `A* Distance Calculated = ${getPathDistance(path, grid, start, nCols)}`\n  );\n  console.log(`A* inspectedNodes = ${inspectedNodes}`);\n  console.log(`A* Dequeues = ${nDeq}`);\n  await pathAnimation(path, start.val);\n};\n\n//   we will use f(n) = alpha * distance + ( 1 - alpha) * Manhattan distance\n// as val to be minimized in the heap\nconst f = (distance, a, b, alpha) => {\n  const g = distance;\n  const h = manhattan(a.row, b.row, a.col, b.col);\n  const w = g === Infinity && alpha === 0 ? Infinity : alpha * g;\n  const z = (1 - alpha) * h;\n  return w + z;\n};\n\nconst getPathDistance = (path, grid, start, nCols) => {\n  // start and finish nodes are not in the path (yelow animation)\n  let d = start.w;\n  for (let i = 0; i < path.length; i++) {\n    let [r, c] = valToIndx(path[i], nCols);\n    const node = grid[r][c];\n    d += node.w;\n  }\n  return d;\n};\nexport default a;\n","const styles = (theme) => ({\n  Navbar: {\n    display: 'flex',\n    alignItems: 'space-around',\n    justifyContent: 'center',\n    height: '6vh',\n    marginBottom: '12px',\n  },\n  title: {\n    display: 'block',\n  },\n  button: {\n    margin: '0 10px',\n    cursor: 'pointer',\n    border: 'none',\n    fontSize: '15px',\n  },\n});\n\nexport default styles;\n","import React from 'react';\nimport bfs from './algorithms/bfs';\nimport dfs from './algorithms/dfs';\nimport dijkstra from './algorithms/dijkstra';\nimport bestFisrtSearch from './algorithms/best-first-search';\nimport a from './algorithms/a';\nimport { clearAnimation, clearPathAnimation } from './animations';\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Typography from '@material-ui/core/Typography';\nimport { withStyles } from '@material-ui/core/styles';\nimport styles from './NavStyles';\nimport { valToIndx, getNewMazedGrid } from './helpers/gridPropertiesHelper';\nimport { getInitialGrid } from './helpers/initialGridHelper';\n\nfunction Nav(props) {\n  const {\n    classes,\n    grid,\n    disable,\n    start,\n    end,\n    setGrid,\n    setDisable,\n    nRows,\n    nCols,\n    isWeighted,\n    setIsWeighted,\n    toggleIsweighted,\n  } = props;\n\n  const clear = () => {\n    clearAnimation(grid, start, end);\n    const n = getInitialGrid(start, end, nRows, nCols, 50);\n    setGrid(n);\n    setIsWeighted(false);\n  };\n\n  const newMaze = async () => {\n    const newGrid = await getNewMazedGrid(grid, 0.33);\n    setGrid(newGrid);\n  };\n\n  const handleClick = async (alg) => {\n    setDisable(true);\n    await alg;\n    setDisable(false);\n  };\n  const [rowEnd, colEnd] = valToIndx(end, nCols);\n  const [rowStart, colStart] = valToIndx(start, nCols);\n\n  return (\n    <AppBar position='static' color='inherit' className={classes.Navbar}>\n      <Toolbar>\n        <Typography className={classes.title} variant='h6' color='inherit'>\n          Pathfinding Visualizer\n        </Typography>\n        <div className={classes.button}>\n          <button\n            className={classes.button}\n            onClick={() => clear()}\n            disabled={disable}\n          >\n            Clear\n          </button>\n          <button\n            className={classes.button}\n            onClick={() => clearPathAnimation(grid)}\n            disabled={disable}\n          >\n            Clear Path\n          </button>\n          <button\n            className={classes.button}\n            onClick={() => handleClick(newMaze())}\n            disabled={disable}\n          >\n            Maze\n          </button>\n          <button\n            className={classes.button}\n            onClick={() => handleClick(toggleIsweighted())}\n            disabled={disable}\n          >\n            Un/Weighted Grid\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                bfs(grid, grid[rowStart][colStart], grid[rowEnd][colEnd], nCols)\n              )\n            }\n            disabled={isWeighted ? true : disable}\n          >\n            BFS\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                dfs(grid, grid[rowStart][colStart], grid[rowEnd][colEnd], nCols)\n              )\n            }\n            disabled={isWeighted ? true : disable}\n          >\n            DFS\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                dijkstra(\n                  grid,\n                  grid[rowStart][colStart],\n                  grid[rowEnd][colEnd],\n                  nCols\n                )\n              )\n            }\n            disabled={!isWeighted ? true : disable}\n          >\n            Dijkstra\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                bestFisrtSearch(\n                  grid,\n                  grid[rowStart][colStart],\n                  grid[rowEnd][colEnd],\n                  nCols\n                )\n              )\n            }\n            disabled={!isWeighted ? true : disable}\n          >\n            Best-First Search\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                a(\n                  grid,\n                  grid[rowStart][colStart],\n                  grid[rowEnd][colEnd],\n                  nCols,\n                  0.1\n                )\n              )\n            }\n            disabled={!isWeighted ? true : disable}\n          >\n            A*\n          </button>\n          <button\n            className={classes.button}\n            onClick={() => {\n              window.open(\n                'https://github.com/LyangHiga/pathfinding-visualizer#instructions',\n                '_blank'\n              );\n            }}\n          >\n            Instructions\n          </button>\n        </div>\n      </Toolbar>\n    </AppBar>\n  );\n}\n\nexport default withStyles(styles)(Nav);\n","import { useState } from \"react\";\nfunction useToggleState(initialVal = false) {\n  // call useState, \"reserve piece of state\"\n  const [state, setState] = useState(initialVal);\n  const toggle = () => {\n    setState(!state);\n  };\n  // return piece of state AND a function to toggle it\n  return [state, setState, toggle];\n}\nexport default useToggleState;\n","import React, { useState, useEffect } from 'react';\nimport Node from './Node';\nimport {\n  getNewGridWithWallToggled,\n  getNewGridWitNewStart,\n  getNewGridWitNewFinish,\n  getRowsCols,\n} from './helpers/gridPropertiesHelper';\nimport { getRandomVertex, getInitialGrid } from './helpers/initialGridHelper';\nimport Nav from './Nav';\nimport './PathFindingVisualizer.css';\nimport {\n  wallAnimation,\n  startNodeAnimation,\n  finishNodeAnimation,\n  clearNodeAnimation,\n  sleep,\n} from './animations';\nimport useToggleState from './hooks/useToggleState';\n\nexport default function PathFindingVisualizer() {\n  const minRows = 20;\n  const minCols = 20;\n  const wRange = 50;\n  const [grid, setGrid] = useState([]);\n  const [nRows, setNRows] = useState();\n  const [nCols, setNCols] = useState();\n  const [isWeighted, setIsWeighted, toggleIsweighted] = useToggleState(false);\n  //   disable buttons in nav\n  const [disable, setDisable] = useState(false);\n  const [startVertex, setStarteVertex] = useState(\n    getRandomVertex(minRows, minCols)\n  );\n  const [finishVertex, setFinishVertex] = useState(\n    getRandomVertex(minRows, minCols)\n  );\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [createWall, setCreatWall, toggleCreateWall] = useToggleState(false);\n  const [changeStart, setChangeStart, toggleChangeStart] = useToggleState(\n    false\n  );\n  const [changeFinish, setChangeFinish, toggleChangeFinish] = useToggleState(\n    false\n  );\n\n  //   run only once, similar to Component Did mount\n  useEffect(() => {\n    async function initialGrid() {\n      document.title = 'Pathfinding Visualizer';\n      const [nRows, nCols] = getRowsCols();\n      setNRows(nRows);\n      setNCols(nCols);\n      const n = getInitialGrid(startVertex, finishVertex, nRows, nCols, wRange);\n      setGrid(n);\n      await sleep(1);\n      startNodeAnimation(startVertex);\n      finishNodeAnimation(finishVertex);\n    }\n    initialGrid();\n  }, []);\n\n  const handleKeyPress = (event) => {\n    switch (event.key) {\n      case 'w':\n        setChangeStart(false);\n        setChangeFinish(false);\n        return toggleCreateWall();\n      case 's':\n        setChangeFinish(false);\n        setCreatWall(false);\n        return toggleChangeStart();\n      case 'f':\n        setChangeStart(false);\n        setCreatWall(false);\n        return toggleChangeFinish();\n      default:\n        return;\n    }\n  };\n\n  const handleMouseDown = (row, col) => {\n    if (createWall) {\n      wallAnimation(grid[row][col]);\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n      setMouseIsPressed(true);\n    } else if (changeStart) {\n      clearNodeAnimation(startVertex);\n      const newGrid = getNewGridWitNewStart(grid, row, col, startVertex, nCols);\n      setStarteVertex(newGrid[row][col].val);\n      setGrid(newGrid);\n      startNodeAnimation(newGrid[row][col].val);\n      setChangeStart(false);\n    } else if (changeFinish) {\n      clearNodeAnimation(finishVertex);\n      const newGrid = getNewGridWitNewFinish(\n        grid,\n        row,\n        col,\n        finishVertex,\n        nCols\n      );\n      setFinishVertex(newGrid[row][col].val);\n      setGrid(newGrid);\n      finishNodeAnimation(newGrid[row][col].val);\n      setChangeFinish(false);\n    }\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mouseIsPressed || !createWall) return;\n    wallAnimation(grid[row][col]);\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  };\n\n  const handleMouseUp = () => {\n    setMouseIsPressed(false);\n  };\n\n  return (\n    <div onKeyDown={handleKeyPress} tabIndex='0'>\n      <Nav\n        grid={grid}\n        setGrid={setGrid}\n        disable={disable}\n        setDisable={setDisable}\n        start={startVertex}\n        end={finishVertex}\n        nRows={nRows}\n        nCols={nCols}\n        isWeighted={isWeighted}\n        setIsWeighted={setIsWeighted}\n        toggleIsweighted={toggleIsweighted}\n      />\n      <div className='grid'>\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node) => {\n                const { row, col, val, adjList, w } = node;\n                return (\n                  <Node\n                    key={val}\n                    val={val}\n                    col={col}\n                    row={row}\n                    onMouseDown={handleMouseDown}\n                    onMouseEnter={handleMouseEnter}\n                    onMouseUp={handleMouseUp}\n                    adjList={adjList}\n                    w={w}\n                    isWeighted={isWeighted}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n","import React from 'react';\nimport PathFindingVisualizer from './PathFindingVisualizer';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}