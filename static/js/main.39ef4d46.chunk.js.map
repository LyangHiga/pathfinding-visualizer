{"version":3,"sources":["Node.js","animations.js","helpers/gridPropertiesHelper.js","helpers/initialGridHelper.js","structures/queue.js","algorithms/bfs.js","structures/stack.js","algorithms/dfs.js","NavStyles.js","Nav.js","hooks/useToggleState.js","PathFindingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","id","val","className","onMouseDown","row","col","onMouseEnter","onMouseUp","sleep","m","Promise","r","setTimeout","pathAnimation","path","a","i","length","changingPropAnimation","visitedAnimation","start","end","color","document","getElementById","style","backgroundColor","wallAnimation","v","isStart","isFinish","startNodeAnimation","finishNodeAnimation","clearNodeAnimation","valToIndx","nCols","Math","floor","getNewGridWithNewProperty","grid","prop","newGrid","slice","c","oldNode","oldPropToggled","toggleNodeProperty","node","newNode","getNewGridWithWallToggled","getNewMazedGrid","eps","random","getPath","parents","dist","push","console","log","reverse","getRowsCols","width","window","innerWidth","documentElement","clientWidth","body","height","innerHeight","clientHeight","getRandomVertex","nRows","createNode","finish","isWall","adjList","createAdjList","b","d","getInitialGrid","currentRow","this","next","Queue","first","last","size","removed","bfs","visited","q","enQueue","deQueue","key","w","wVertex","Stack","dfs","result","stack","pop","styles","theme","Navbar","display","alignItems","justifyContent","marginBottom","title","button","margin","cursor","border","fontSize","withStyles","classes","disable","setGrid","setDisable","clear","startVal","finishVal","j","clearAnimation","n","newMaze","handleClick","alg","rowEnd","colEnd","rowStart","colStart","AppBar","position","Toolbar","Typography","variant","onClick","disabled","vertex","clearPathAnimation","useToggleState","initialVal","useState","state","setState","toggle","PathFindingVisualizer","setNRows","setNCols","startVertex","setStarteVertex","finishVertex","setFinishVertex","mouseIsPressed","setMouseIsPressed","createWall","setCreatWall","toggleCreateWall","changeStart","setChangeStart","toggleChangeStart","changeFinish","setChangeFinish","toggleChangeFinish","useEffect","initialGrid","handleMouseDown","getNewGridWitNewStart","getNewGridWitNewFinish","handleMouseEnter","handleMouseUp","onKeyDown","event","tabIndex","map","rowIdx","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.39ef4d46.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.css';\n\nexport default function Node(props) {\n  return (\n    <div\n      id={`node-${props.val}`}\n      className={'node'}\n      onMouseDown={() => props.onMouseDown(props.row, props.col)}\n      onMouseEnter={() => props.onMouseEnter(props.row, props.col)}\n      onMouseUp={() => props.onMouseUp()}\n    ></div>\n  );\n}\n","export const sleep = (m) => new Promise((r) => setTimeout(r, m));\n\nexport const pathAnimation = async (path) => {\n  for (let i = 0; i < path.length; i++) {\n    await sleep(12);\n    changingPropAnimation(path[i], 'yellow');\n  }\n};\n\nexport const visitedAnimation = async (val, start, end) => {\n  if (val === end) return;\n  if (val === start) return;\n  await sleep(7);\n  changingPropAnimation(val, 'blue');\n};\n\nexport const clearAnimation = (grid, startVal, finishVal) => {\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const v = grid[i][j];\n      changingPropAnimation(v.val, 'white');\n      if (v.val === startVal) {\n        changingPropAnimation(v.val, 'green');\n      }\n      if (v.val === finishVal) {\n        changingPropAnimation(v.val, 'red');\n      }\n    }\n  }\n};\n\nconst changingPropAnimation = (val, color) => {\n  const vertex = document.getElementById(`node-${val}`).style;\n  vertex.backgroundColor = `${color}`;\n};\n\nexport const wallAnimation = async (v) => {\n  if (v.isStart || v.isFinish) return;\n  await sleep(1);\n  changingPropAnimation(v.val, 'rgb(12, 53, 71)');\n};\n\nexport const startNodeAnimation = (val) => {\n  changingPropAnimation(val, 'green');\n};\n\nexport const finishNodeAnimation = (val) => {\n  changingPropAnimation(val, 'red');\n};\n\nexport const clearNodeAnimation = (val) => {\n  changingPropAnimation(val, 'white');\n};\n\nexport const clearPathAnimation = (grid) => {\n  let vertex;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const v = grid[i][j];\n      vertex = document.getElementById(`node-${v.val}`).style;\n      if (\n        vertex.backgroundColor === 'blue' ||\n        vertex.backgroundColor === 'yellow'\n      ) {\n        clearNodeAnimation(v.val, 'white');\n      }\n    }\n  }\n};\n","import { wallAnimation } from '../animations';\n\n// Node Helpers\n\n// returns {row, col} of a vertex val\nexport const valToIndx = (val, nCols) => {\n  const row = Math.floor(val / nCols);\n  const col = val - row * nCols;\n  return [row, col];\n};\n\n// Grid Helpers\n\nconst getNewGridWithNewProperty = (grid, row, col, prop, val, nCols) => {\n  const newGrid = grid.slice();\n  const [r, c] = valToIndx(val, nCols);\n  const oldNode = newGrid[r][c];\n  const oldPropToggled = toggleNodeProperty(oldNode, `${prop}`);\n  newGrid[r][c] = oldPropToggled;\n  const node = newGrid[row][col];\n  const newNode = toggleNodeProperty(node, `${prop}`);\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (wall is created)\nexport const getNewGridWithWallToggled = (grid, row, col) => {\n  if (grid[row][col].isStart || grid[row][col].isFinish) return grid;\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = toggleNodeProperty(node, 'isWall');\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (new start node)\nexport const getNewGridWitNewStart = (grid, row, col, startVal, nCols) => {\n  const newGrid = getNewGridWithNewProperty(\n    grid,\n    row,\n    col,\n    'isStart',\n    startVal,\n    nCols\n  );\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (new finish point)\nexport const getNewGridWitNewFinish = (grid, row, col, finishVal, nCols) => {\n  const newGrid = getNewGridWithNewProperty(\n    grid,\n    row,\n    col,\n    'isFinish',\n    finishVal,\n    nCols\n  );\n  return newGrid;\n};\n\n// returns a new mazed grid\n// a node has eps to be a wall\nexport const getNewMazedGrid = async (grid, eps) => {\n  let newGrid = grid.slice();\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      if (grid[row][col].isStart || grid[row][col].isFinish) {\n        break;\n      }\n      if (Math.random() <= eps) {\n        const node = newGrid[row][col];\n        const newNode = toggleNodeProperty(node, 'isWall');\n        newGrid[row][col] = newNode;\n        await wallAnimation(newGrid[row][col]);\n      }\n    }\n  }\n  return newGrid;\n};\n\nconst toggleNodeProperty = (node, prop) => {\n  const newNode = {\n    ...node,\n    [prop]: !node.prop,\n  };\n  return newNode;\n};\n\n//   building path\nexport const getPath = (parents, end, dist) => {\n  let a = parents[end];\n  let path = [];\n  for (let i = 0; i < dist - 1; i++) {\n    path.push(a);\n    a = parents[a];\n  }\n  console.log(`Min Path: ${path.length + 1} squares`);\n  return path.reverse();\n};\n\n// return number of rows and cols to display in this screen\nexport const getRowsCols = () => {\n  const width =\n    window.innerWidth ||\n    document.documentElement.clientWidth ||\n    document.body.clientWidth;\n  const height =\n    window.innerHeight ||\n    document.documentElement.clientHeight ||\n    document.body.clientHeight;\n  const nRows = Math.floor(width / 60);\n  const nCols = Math.floor(height / 15);\n  return [nRows, nCols];\n};\n","// import { NUM_COL, NUM_ROW } from '../consts';\n\n// returns a random vertex value\nexport const getRandomVertex = (nRows, nCols) => {\n  return Math.floor(Math.random() * nRows * nCols);\n};\n\nconst createNode = (col, row, start, finish, nRows, nCols) => {\n  const val = row * nCols + col;\n  const adjList = createAdjList(val, col, row, nRows, nCols);\n\n  return {\n    col,\n    row,\n    isStart: val === start,\n    isFinish: val === finish,\n    isWall: false,\n    adjList: adjList,\n    val: val,\n  };\n};\n\n//         A\n//    B   VAL  D\n//         C\n// returns all neighbours of VAL\nconst createAdjList = (val, col, row, nRows, nCols) => {\n  //   neighbours in a line above\n  // negative numbers arent a node\n  const a = row !== 0 ? val - nCols : null;\n  // neighbours in the same line\n  // check left border\n  const b = col !== 0 ? val - 1 : null;\n  // check right border\n  const d = col !== nCols - 1 ? val + 1 : null;\n  //  neighbours in a line bellow\n  // check overflow\n  const c = row !== nRows - 1 ? val + nCols : null;\n\n  return { a, b, c, d };\n};\n\n// returns the initial Grid\nexport const getInitialGrid = (start, finish, nRows, nCols) => {\n  const grid = [];\n  for (let row = 0; row < nRows; row++) {\n    const currentRow = [];\n    for (let col = 0; col < nCols; col++) {\n      currentRow.push(createNode(col, row, start, finish, nRows, nCols));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n","// linked list Node\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n// Queue implementation, FIFO, through linked list\nclass Queue {\n  constructor() {\n    this.first = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  // add to the end and return the size of this queue\n  enQueue(val) {\n    let node = new Node(val);\n    if (this.size === 0) {\n      this.first = node;\n      this.last = node;\n    } else {\n      this.last.next = node;\n      this.last = node;\n    }\n    this.size++;\n    return this.size;\n  }\n\n  // remove the first node and return it\n  deQueue() {\n    if (this.size === 0) return null;\n    let removed = this.first;\n    if (this.size === 1) {\n      this.first = null;\n      this.last = null;\n    } else {\n      this.first = removed.next;\n      removed.next = null;\n    }\n    this.size--;\n    return removed;\n  }\n}\n\nexport default Queue;\n","import Queue from '../structures/queue';\nimport { valToIndx, getPath } from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst bfs = async (grid, start, end, nCols) => {\n  let visited = {};\n  let parents = {};\n  let dist = {};\n  let q = new Queue();\n  // add start vertex to the queue\n  q.enQueue(start);\n  // start vertex is already visited\n  visited[start.val] = true;\n  dist[start.val] = 0;\n  parents[start.val] = null;\n  // vertex that will be deQueue\n  let v;\n  while (q.size !== 0) {\n    v = q.deQueue().val;\n    // check if v is the end vertex\n    if (v.val === end.val) {\n      //   we find the target\n      break;\n    }\n    // for every edge of v\n    for (const key in v.adjList) {\n      const w = v.adjList[key];\n      const [row, col] = valToIndx(w, nCols);\n      //   wVertex has all properties while w is wVeterx.val\n      const wVertex = grid[row][col];\n      //   check w is visited, is not null or wall\n      if (visited[w] !== true && w !== null && !wVertex.isWall) {\n        //mark  w as visited\n        visited[w] = true;\n        await visitedAnimation(w, start.val, end.val);\n        //   enQueue vertex w\n        q.enQueue(wVertex);\n        parents[w] = v.val;\n        dist[w] = dist[v.val] + 1;\n      }\n    }\n  }\n  const path = getPath(parents, end.val, dist[end.val]);\n  await pathAnimation(path, start.val);\n};\n\nexport default bfs;\n","// linked list Node\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n// simple implementation using SLL, shift and unshift, here called as push and pop\n// First in Last Out\nclass Stack {\n  constructor() {\n    this.first = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  // add a node at the beginning and return the size of this stack\n  push(val) {\n    let node = new Node(val);\n    if (this.size === 0) {\n      this.first = node;\n      this.last = node;\n    } else {\n      node.next = this.first;\n      this.first = node;\n    }\n    this.size++;\n    return this.size;\n  }\n  // remove the first node and return it\n  pop() {\n    // empty stack\n    if (this.size === 0) return null;\n    let removed = this.first;\n    if (this.size === 1) {\n      this.first = null;\n      this.last = null;\n    } else {\n      this.first = removed.next;\n      removed.next = null;\n    }\n    this.size--;\n    return removed;\n  }\n}\n\nexport default Stack;\n","import Stack from '../structures/stack';\nimport { valToIndx } from '../helpers/gridPropertiesHelper';\nimport { visitedAnimation } from '../animations';\n\nconst dfs = async (grid, start, end, nCols) => {\n  //   const end = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n  //   stack pop order\n  let result = [];\n  let visited = {};\n  let stack = new Stack();\n  // add start vertex to the stack\n  stack.push(start);\n  // start vertex is already visited\n  visited[start.val] = true;\n  let v;\n  while (stack.size !== 0) {\n    // take vertex v from the top of the stack\n    v = stack.pop().val;\n    result.push(v.val);\n    if (v.val === end.val) {\n      //   we find the target\n      break;\n    }\n    // mark w as visited\n    visited[v.val] = true;\n    await visitedAnimation(v.val, start.val, end.val);\n    // for every edge of v\n    for (const key in v.adjList) {\n      const w = v.adjList[key];\n      const [row, col] = valToIndx(w, nCols);\n      //   wVertex has all properties while w is wVeterx.val\n      const wVertex = grid[row][col];\n      //   check w is visited, is not null or wall\n      if (visited[w] !== true && w !== null && !wVertex.isWall) {\n        //   push w vertex\n        stack.push(wVertex);\n        if (w === end.val) {\n          //   we find the target\n          break;\n        }\n      }\n    }\n  }\n};\n\nexport default dfs;\n","const styles = (theme) => ({\n  Navbar: {\n    display: 'flex',\n    alignItems: 'space-around',\n    justifyContent: 'center',\n    height: '6vh',\n    marginBottom: '20px',\n  },\n  title: {\n    display: 'block',\n  },\n  button: {\n    margin: '0 10px',\n    cursor: 'pointer',\n    border: 'none',\n    fontSize: '15px',\n  },\n});\n\nexport default styles;\n","import React from 'react';\nimport bfs from './algorithms/bfs';\nimport dfs from './algorithms/dfs';\nimport { clearAnimation, clearPathAnimation } from './animations';\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Typography from '@material-ui/core/Typography';\nimport { withStyles } from '@material-ui/core/styles';\nimport styles from './NavStyles';\nimport { valToIndx, getNewMazedGrid } from './helpers/gridPropertiesHelper';\nimport { getInitialGrid } from './helpers/initialGridHelper';\n\nfunction Nav(props) {\n  const {\n    classes,\n    grid,\n    disable,\n    start,\n    end,\n    setGrid,\n    setDisable,\n    nRows,\n    nCols,\n  } = props;\n\n  const clear = () => {\n    clearAnimation(grid, start, end);\n    const n = getInitialGrid(start, end, nRows, nCols);\n    setGrid(n);\n  };\n\n  const newMaze = async () => {\n    const newGrid = await getNewMazedGrid(grid, 0.33);\n    setGrid(newGrid);\n  };\n\n  const handleClick = async (alg) => {\n    setDisable(true);\n    await alg;\n    setDisable(false);\n  };\n  const [rowEnd, colEnd] = valToIndx(end, nCols);\n  const [rowStart, colStart] = valToIndx(start, nCols);\n\n  return (\n    <AppBar position='static' color='inherit' className={classes.Navbar}>\n      <Toolbar>\n        <Typography className={classes.title} variant='h6' color='inherit'>\n          Pathfinding Visualizer\n        </Typography>\n        <div className={classes.button}>\n          <button\n            className={classes.button}\n            onClick={() => clear()}\n            disabled={disable}\n          >\n            Clear\n          </button>\n          <button\n            className={classes.button}\n            onClick={() => clearPathAnimation(grid)}\n            disabled={disable}\n          >\n            Clear Path\n          </button>\n          <button\n            className={classes.button}\n            onClick={() => handleClick(newMaze())}\n            disabled={disable}\n          >\n            Maze\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                bfs(grid, grid[rowStart][colStart], grid[rowEnd][colEnd], nCols)\n              )\n            }\n            disabled={disable}\n          >\n            BFS\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                dfs(grid, grid[rowStart][colStart], grid[rowEnd][colEnd], nCols)\n              )\n            }\n            disabled={disable}\n          >\n            DFS\n          </button>\n        </div>\n      </Toolbar>\n    </AppBar>\n  );\n}\n\nexport default withStyles(styles)(Nav);\n","import { useState } from \"react\";\nfunction useToggleState(initialVal = false) {\n  // call useState, \"reserve piece of state\"\n  const [state, setState] = useState(initialVal);\n  const toggle = () => {\n    setState(!state);\n  };\n  // return piece of state AND a function to toggle it\n  return [state, setState, toggle];\n}\nexport default useToggleState;\n","import React, { useState, useEffect } from 'react';\nimport Node from './Node';\nimport {\n  getNewGridWithWallToggled,\n  getNewGridWitNewStart,\n  getNewGridWitNewFinish,\n  getRowsCols,\n} from './helpers/gridPropertiesHelper';\nimport { getRandomVertex, getInitialGrid } from './helpers/initialGridHelper';\nimport Nav from './Nav';\nimport './PathFindingVisualizer.css';\nimport {\n  wallAnimation,\n  startNodeAnimation,\n  finishNodeAnimation,\n  clearNodeAnimation,\n  sleep,\n} from './animations';\nimport useToggleState from './hooks/useToggleState';\n\nexport default function PathFindingVisualizer() {\n  const [grid, setGrid] = useState([]);\n  const [nRows, setNRows] = useState();\n  const [nCols, setNCols] = useState();\n  const [disable, setDisable] = useState(false);\n  const [startVertex, setStarteVertex] = useState(getRandomVertex(4, 7));\n  const [finishVertex, setFinishVertex] = useState(getRandomVertex(6, 9));\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [createWall, setCreatWall, toggleCreateWall] = useToggleState(false);\n  const [changeStart, setChangeStart, toggleChangeStart] = useToggleState(\n    false\n  );\n  const [changeFinish, setChangeFinish, toggleChangeFinish] = useToggleState(\n    false\n  );\n\n  //   run only once, similar to Component Did mount\n  useEffect(() => {\n    async function initialGrid() {\n      const [nRows, nCols] = getRowsCols();\n      setNRows(nRows);\n      setNCols(nCols);\n      const n = getInitialGrid(startVertex, finishVertex, nRows, nCols);\n      setGrid(n);\n      await sleep(1);\n      startNodeAnimation(startVertex);\n      finishNodeAnimation(finishVertex);\n    }\n    initialGrid();\n  }, []);\n\n  const handleKeyPress = (event) => {\n    switch (event.key) {\n      case 'w':\n        setChangeStart(false);\n        setChangeFinish(false);\n        return toggleCreateWall();\n      case 's':\n        setChangeFinish(false);\n        setCreatWall(false);\n        return toggleChangeStart();\n      case 'f':\n        setChangeStart(false);\n        setCreatWall(false);\n        return toggleChangeFinish();\n      default:\n        return;\n    }\n  };\n\n  const handleMouseDown = (row, col) => {\n    if (createWall) {\n      wallAnimation(grid[row][col]);\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n      setMouseIsPressed(true);\n    } else if (changeStart) {\n      clearNodeAnimation(startVertex);\n      const newGrid = getNewGridWitNewStart(grid, row, col, startVertex, nCols);\n      setStarteVertex(newGrid[row][col].val);\n      setGrid(newGrid);\n      startNodeAnimation(newGrid[row][col].val);\n      setChangeStart(false);\n    } else if (changeFinish) {\n      clearNodeAnimation(finishVertex);\n      const newGrid = getNewGridWitNewFinish(\n        grid,\n        row,\n        col,\n        finishVertex,\n        nCols\n      );\n      setFinishVertex(newGrid[row][col].val);\n      setGrid(newGrid);\n      finishNodeAnimation(newGrid[row][col].val);\n      setChangeFinish(false);\n    }\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mouseIsPressed || !createWall) return;\n    wallAnimation(grid[row][col]);\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  };\n\n  const handleMouseUp = () => {\n    setMouseIsPressed(false);\n  };\n\n  return (\n    <div onKeyDown={handleKeyPress} tabIndex='0'>\n      <Nav\n        grid={grid}\n        setGrid={setGrid}\n        disable={disable}\n        setDisable={setDisable}\n        start={startVertex}\n        end={finishVertex}\n        nRows={nRows}\n        nCols={nCols}\n      />\n      <div className='grid'>\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node) => {\n                const { row, col, val, adjList } = node;\n                return (\n                  <Node\n                    key={val}\n                    val={val}\n                    col={col}\n                    row={row}\n                    onMouseDown={handleMouseDown}\n                    onMouseEnter={handleMouseEnter}\n                    onMouseUp={handleMouseUp}\n                    adjList={adjList}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n","import React from 'react';\nimport PathFindingVisualizer from './PathFindingVisualizer';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}