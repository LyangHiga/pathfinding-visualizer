{"version":3,"sources":["animations.js","Node.js","hooks/useToggleState.js","hooks/useWindowDim.js","PathFindingVisualizer.js","App.js","serviceWorker.js","index.js","helpers/gridPropertiesHelper.js","helpers/initialGridHelper.js","algorithms/bellmanFord.js","structures/heap.js","algorithms/a.js","Nav.js","NavStyles.js","structures/queue.js","algorithms/bfs.js","structures/stack.js","algorithms/dfs.js"],"names":["sleep","m","Promise","r","setTimeout","pathAnimation","path","a","i","length","changingPropAnimation","visitedAnimation","val","start","end","color","clearAnimation","grid","startVal","finishVal","j","v","document","getElementById","style","backgroundColor","wallAnimation","isStart","isFinish","startNodeAnimation","finishNodeAnimation","clearNodeAnimation","clearPathAnimation","isWall","Node","props","id","className","onMouseDown","row","col","onMouseEnter","onMouseUp","isWeighted","w","useToggleState","initialVal","useState","state","setState","toggle","getWindowDimensions","window","width","innerWidth","height","innerHeight","PathFindingVisualizer","setGrid","windowDimensions","setWindowDimensions","useEffect","handleResize","addEventListener","removeEventListener","useWindowDimensions","theme","useTheme","nRows","useMediaQuery","breakpoints","down","Math","floor","nCols","setIsWeighted","toggleIsweighted","isNegative","toggleIsNegative","disable","setDisable","getRandomVertex","startVertex","setStarteVertex","finishVertex","setFinishVertex","mouseIsPressed","setMouseIsPressed","createWall","setCreatWall","toggleCreateWall","changeStart","setChangeStart","toggleChangeStart","changeFinish","setChangeFinish","toggleChangeFinish","handleChangeStart","handleChangeFinish","title","n","getInitialGrid","initialGrid","handleMouseDown","newGrid","getNewGridWithWallToggled","getNewGridWitNewStart","getNewGridWitNewFinish","handleMouseEnter","handleMouseUp","onKeyDown","event","key","tabIndex","Nav","wRange","map","rowIdx","node","adjList","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message","manhattan","b","c","d","abs","valToIndx","getNewGridWithNewProperty","prop","slice","oldNode","oldPropToggled","toggleNodeProperty","newNode","getNewMazedGrid","eps","random","getPath","parents","dist","push","log","reverse","getWeightedPath","createNode","finish","createAdjList","max","min","currentRow","bellmanFord","distances","Array","fill","Infinity","stop","k","neighbour","nextVertex","alert","this","Heap","values","idxs","undefined","idx","l","smallIdx","lessThan","contains","parentIdx","myParentIdx","bubbleUp","newVal","element","pop","heap","myChildrenIdx","lChild","rChild","bubbleDown","alpha","SCALING_FACTOR","inspectedNodes","nDeq","enqueue","f","s","dequeue","smallestVal","found","smallest","newF","oldF","decreaseKey","getPathDistance","distance","sf","classes","styles","matchesSM","openDrawer","setOpenDrawer","iOS","process","browser","test","userAgent","rowEnd","colEnd","rowStart","colStart","setAlpha","fName","setFName","openAlert","setOpenAlert","handleClickOpenAlert","handleCloseAlert","changeAlpha","clear","newMaze","handleClick","alg","hanldeSliderChange","btnOptList","name","click","disabled","unWBtnsList","bfs","dfs","btnOpts","btn","button","onClick","unWBtns","text","wBtns","slider","defaultValue","onAfterChange","onChange","step","negBtns","open","onClose","aria-labelledby","aria-describedby","autoFocus","btns","btnOpt","drawer","disableBackdropTransition","disableDiscovery","onOpen","disablePadding","divider","drawerIconContainer","disableRipple","position","Navbar","variant","makeStyles","marginBottom","up","marginRight","paddingRight","borderRight","padding","margin","fontSize","textTransform","outline","border","boxShadow","marginLeft","marginTop","next","Queue","first","last","size","removed","visited","q","enQueue","deQueue","wVertex","Stack","result","stack"],"mappings":"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","file":"static/js/main.e7f2d4f2.chunk.js","sourcesContent":["// TODO: Refactoring Colors\n\nexport const sleep = (m) => new Promise((r) => setTimeout(r, m));\n\nexport const pathAnimation = async (path) => {\n  for (let i = 0; i < path.length; i++) {\n    await sleep(12);\n    changingPropAnimation(path[i], \"yellow\");\n  }\n};\n\nexport const visitedAnimation = async (val, start, end, color = \"blue\") => {\n  if (val === end) return;\n  if (val === start) return;\n  await sleep(0.01);\n  changingPropAnimation(val, color);\n};\n\nexport const clearAnimation = (grid, startVal, finishVal) => {\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const v = grid[i][j];\n      changingPropAnimation(v.val, \"white\");\n      if (v.val === startVal) {\n        changingPropAnimation(v.val, \"green\");\n      }\n      if (v.val === finishVal) {\n        changingPropAnimation(v.val, \"red\");\n      }\n    }\n  }\n};\n\nconst changingPropAnimation = (val, color) => {\n  const vertex = document.getElementById(`node-${val}`).style;\n  vertex.backgroundColor = `${color}`;\n};\n\nexport const wallAnimation = async (v) => {\n  if (v.isStart || v.isFinish) return;\n  await sleep(1);\n  changingPropAnimation(v.val, \"black\");\n};\n\nexport const startNodeAnimation = (val) => {\n  changingPropAnimation(val, \"green\");\n};\n\nexport const finishNodeAnimation = (val) => {\n  changingPropAnimation(val, \"red\");\n};\n\nexport const clearNodeAnimation = (val) => {\n  changingPropAnimation(val, \"white\");\n};\n\nexport const clearPathAnimation = (grid) => {\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const v = grid[i][j];\n      if (!v.isStart && !v.isFinish && !v.isWall) {\n        clearNodeAnimation(v.val, \"white\");\n      }\n    }\n  }\n};\n","import React from 'react';\nimport './Node.css';\n\nexport default function Node(props) {\n  return (\n    <div\n      id={`node-${props.val}`}\n      className={'node'}\n      onMouseDown={() => props.onMouseDown(props.row, props.col)}\n      onMouseEnter={() => props.onMouseEnter(props.row, props.col)}\n      onMouseUp={() => props.onMouseUp()}\n    >\n      {props.isWeighted ? <span>{props.w}</span> : ''}\n    </div>\n  );\n}\n","import { useState } from \"react\";\nfunction useToggleState(initialVal = false) {\n  // call useState, \"reserve piece of state\"\n  const [state, setState] = useState(initialVal);\n  const toggle = () => {\n    setState(!state);\n  };\n  // return piece of state AND a function to toggle it\n  return [state, setState, toggle];\n}\nexport default useToggleState;\n","import { useState, useEffect } from \"react\";\n\nfunction getWindowDimensions() {\n  const { innerWidth: width, innerHeight: height } = window;\n  return {\n    width,\n    height,\n  };\n}\n\nexport default function useWindowDimensions() {\n  const [windowDimensions, setWindowDimensions] = useState(\n    getWindowDimensions()\n  );\n\n  useEffect(() => {\n    function handleResize() {\n      setWindowDimensions(getWindowDimensions());\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  return windowDimensions;\n}\n\n// Check:\n// https://stackoverflow.com/questions/36862334/get-viewport-window-height-in-reactjs\n","// TODO: Change start and finish node in mobile node, reorganize files\n// TODO: Refactoring with TypeSCript\n// TODO: Handle state with useReducer !? is probably better\n// TODO: Context api to global state is probably better than share state using props\n\nimport React, { useState, useEffect } from \"react\";\nimport useMediaQuery from \"@material-ui/core/useMediaQuery\";\nimport { useTheme } from \"@material-ui/core/styles\";\nimport Node from \"./Node\";\nimport {\n  getNewGridWithWallToggled,\n  getNewGridWitNewStart,\n  getNewGridWitNewFinish,\n} from \"./helpers/gridPropertiesHelper\";\nimport { getRandomVertex, getInitialGrid } from \"./helpers/initialGridHelper\";\nimport Nav from \"./Nav\";\nimport \"./PathFindingVisualizer.css\";\nimport {\n  wallAnimation,\n  startNodeAnimation,\n  finishNodeAnimation,\n  clearNodeAnimation,\n  sleep,\n} from \"./animations\";\nimport useToggleState from \"./hooks/useToggleState\";\nimport useWindowDimensions from \"./hooks/useWindowDim\";\n\nexport default function PathFindingVisualizer() {\n  // max edge weight\n  const wRange = 201;\n  const [grid, setGrid] = useState([]);\n  const { height, width } = useWindowDimensions();\n  const theme = useTheme();\n  const matchesSM = useMediaQuery(theme.breakpoints.down(\"sm\"));\n  // 87% or 80%(SM display) of total height: discount nav height\n  const nRows = matchesSM\n    ? Math.floor((height * 0.8) / 27)\n    : Math.floor((height * 0.87) / 27);\n  const nCols = Math.floor(width / 27);\n  const [isWeighted, setIsWeighted, toggleIsweighted] = useToggleState(false);\n  const [isNegative, setIsNegative, toggleIsNegative] = useToggleState(false);\n  //   disable buttons in nav\n  const [disable, setDisable] = useState(false);\n  const [startVertex, setStarteVertex] = useState(\n    getRandomVertex(nRows, nCols)\n  );\n  const [finishVertex, setFinishVertex] = useState(\n    getRandomVertex(nRows, nCols)\n  );\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [createWall, setCreatWall, toggleCreateWall] = useToggleState(false);\n  const [changeStart, setChangeStart, toggleChangeStart] = useToggleState(\n    false\n  );\n  const [changeFinish, setChangeFinish, toggleChangeFinish] = useToggleState(\n    false\n  );\n\n  const handleChangeStart = () => {\n    setChangeFinish(false);\n    setCreatWall(false);\n    toggleChangeStart();\n  };\n\n  const handleChangeFinish = () => {\n    setChangeStart(false);\n    setCreatWall(false);\n    toggleChangeFinish();\n  };\n\n  //   run only once, similar to Component Did mount\n  useEffect(() => {\n    async function initialGrid() {\n      document.title = \"Pathfinding Visualizer\";\n      const n = getInitialGrid(startVertex, finishVertex, nRows, nCols, wRange);\n      setGrid(n);\n      await sleep(1);\n      startNodeAnimation(startVertex);\n      finishNodeAnimation(finishVertex);\n    }\n    initialGrid();\n  }, []);\n\n  const handleKeyPress = (event) => {\n    switch (event.key) {\n      case \"w\":\n        setChangeStart(false);\n        setChangeFinish(false);\n        return toggleCreateWall();\n      case \"s\":\n        return handleChangeStart();\n      case \"f\":\n        return handleChangeFinish();\n      default:\n        return;\n    }\n  };\n\n  const handleMouseDown = (row, col) => {\n    if (createWall) {\n      wallAnimation(grid[row][col]);\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n      setMouseIsPressed(true);\n    } else if (changeStart) {\n      clearNodeAnimation(startVertex);\n      const newGrid = getNewGridWitNewStart(grid, row, col, startVertex, nCols);\n      setStarteVertex(newGrid[row][col].val);\n      setGrid(newGrid);\n      startNodeAnimation(newGrid[row][col].val);\n      setChangeStart(false);\n    } else if (changeFinish) {\n      clearNodeAnimation(finishVertex);\n      const newGrid = getNewGridWitNewFinish(\n        grid,\n        row,\n        col,\n        finishVertex,\n        nCols\n      );\n      setFinishVertex(newGrid[row][col].val);\n      setGrid(newGrid);\n      finishNodeAnimation(newGrid[row][col].val);\n      setChangeFinish(false);\n    }\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mouseIsPressed || !createWall) return;\n    wallAnimation(grid[row][col]);\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  };\n\n  const handleMouseUp = () => {\n    setMouseIsPressed(false);\n  };\n\n  return (\n    <div onKeyDown={handleKeyPress} tabIndex=\"0\">\n      <Nav\n        grid={grid}\n        setGrid={setGrid}\n        disable={disable}\n        setDisable={setDisable}\n        start={startVertex}\n        end={finishVertex}\n        nRows={nRows}\n        nCols={nCols}\n        wRange={wRange}\n        isWeighted={isWeighted}\n        setIsWeighted={setIsWeighted}\n        toggleIsweighted={toggleIsweighted}\n        isNegative={isNegative}\n        toggleIsNegative={toggleIsNegative}\n        handleChangeStart={handleChangeStart}\n        handleChangeFinish={handleChangeFinish}\n      />\n      <div className=\"grid\">\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node) => {\n                const { row, col, val, adjList, w } = node;\n                return (\n                  <Node\n                    key={val}\n                    val={val}\n                    col={col}\n                    row={row}\n                    onMouseDown={handleMouseDown}\n                    onMouseEnter={handleMouseEnter}\n                    onMouseUp={handleMouseUp}\n                    adjList={adjList}\n                    w={w}\n                    isWeighted={isWeighted}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n","import React from 'react';\nimport PathFindingVisualizer from './PathFindingVisualizer';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { wallAnimation } from \"../animations\";\n\n// Node Helpers\n\nexport const manhattan = (a, b, c, d) => {\n  return Math.abs(a - b) + Math.abs(c - d);\n};\n\n// returns {row, col} of a vertex val\nexport const valToIndx = (val, nCols) => {\n  const row = Math.floor(val / nCols);\n  const col = val - row * nCols;\n  return [row, col];\n};\n\n// Grid Helpers\n\nconst getNewGridWithNewProperty = (grid, row, col, prop, val, nCols) => {\n  const newGrid = grid.slice();\n  const [r, c] = valToIndx(val, nCols);\n  const oldNode = newGrid[r][c];\n  const oldPropToggled = toggleNodeProperty(oldNode, prop, false);\n  newGrid[r][c] = oldPropToggled;\n  const node = newGrid[row][col];\n  const newNode = toggleNodeProperty(node, prop, true);\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (wall is created)\nexport const getNewGridWithWallToggled = (grid, row, col) => {\n  if (grid[row][col].isStart || grid[row][col].isFinish) return grid;\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = toggleNodeProperty(node, \"isWall\", !node.isWall);\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (new start node)\nexport const getNewGridWitNewStart = (grid, row, col, startVal, nCols) => {\n  const newGrid = getNewGridWithNewProperty(\n    grid,\n    row,\n    col,\n    \"isStart\",\n    startVal,\n    nCols\n  );\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (new finish point)\nexport const getNewGridWitNewFinish = (grid, row, col, finishVal, nCols) => {\n  const newGrid = getNewGridWithNewProperty(\n    grid,\n    row,\n    col,\n    \"isFinish\",\n    finishVal,\n    nCols\n  );\n  return newGrid;\n};\n\n// returns a new mazed grid\n// a node has eps prob to become a wall\nexport const getNewMazedGrid = async (grid, eps) => {\n  let newGrid = grid.slice();\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      if (grid[row][col].isStart || grid[row][col].isFinish) {\n        break;\n      }\n      if (Math.random() <= eps) {\n        const node = newGrid[row][col];\n        const newNode = toggleNodeProperty(node, \"isWall\", true);\n        newGrid[row][col] = newNode;\n        await wallAnimation(newGrid[row][col]);\n      }\n    }\n  }\n  return newGrid;\n};\n\nconst toggleNodeProperty = (node, prop, val) => {\n  const newNode = {\n    ...node,\n    [prop]: val,\n  };\n  return newNode;\n};\n\n//   building path\nexport const getPath = (parents, end, dist) => {\n  let a = parents[end];\n  let path = [];\n  for (let i = 0; i < dist - 1; i++) {\n    path.push(a);\n    a = parents[a];\n  }\n  console.log(`Min Path: ${path.length + 1} squares`);\n  return path.reverse();\n};\n\n//   building path\nexport const getWeightedPath = (parents, start, end) => {\n  let a = parents[end];\n  let path = [];\n  while (a !== start) {\n    path.push(a);\n    a = parents[a];\n  }\n  return path.reverse();\n};\n","// import { NUM_COL, NUM_ROW } from '../consts';\n\n// returns a random vertex value\nexport const getRandomVertex = (nRows, nCols) => {\n  return Math.floor(Math.random() * nRows * nCols);\n};\n\nconst createNode = (col, row, start, finish, nRows, nCols, w = 1) => {\n  const val = row * nCols + col;\n  const adjList = createAdjList(val, col, row, nRows, nCols);\n\n  return {\n    col,\n    row,\n    isStart: val === start,\n    isFinish: val === finish,\n    isWall: false,\n    adjList: adjList,\n    val: val,\n    w,\n  };\n};\n\n//         A\n//    B   VAL  D\n//         C\n// returns all neighbours of VAL\nconst createAdjList = (val, col, row, nRows, nCols) => {\n  //   neighbours in a line above\n  // negative numbers arent a node\n  const a = row !== 0 ? val - nCols : null;\n  // neighbours in the same line\n  // check left border\n  const b = col !== 0 ? val - 1 : null;\n  // check right border\n  const d = col !== nCols - 1 ? val + 1 : null;\n  //  neighbours in a line bellow\n  // check overflow\n  const c = row !== nRows - 1 ? val + nCols : null;\n\n  return { a, b, c, d };\n};\n\n// returns the initial Grid\nexport const getInitialGrid = (\n  start,\n  finish,\n  nRows,\n  nCols,\n  max = 1,\n  min = 1\n) => {\n  const grid = [];\n  for (let row = 0; row < nRows; row++) {\n    const currentRow = [];\n    for (let col = 0; col < nCols; col++) {\n      // get random weight for all edges of this node\n      const w = Math.floor(Math.random() * (max - min) + min);\n      currentRow.push(createNode(col, row, start, finish, nRows, nCols, w));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n","import { valToIndx, getWeightedPath } from \"../helpers/gridPropertiesHelper\";\nimport {\n  pathAnimation,\n  visitedAnimation,\n  clearPathAnimation,\n} from \"../animations\";\n\n// Returns the distance from s to each vertex and their parents O(mn)\n// negative costs are allowed\n// SSSP (Single Source Shortest Problem)\n// detect negative cycles: boolean output (cycle)\n// use parents (predecessor pointers) to traverse the path\nconst bellmanFord = async (grid, start, end, nCols) => {\n  // O(m) space => to reconstruct path from s to (any) v\n  // parents  (predecessor pointers)\n  const distances = Array(grid.length * nCols).fill(Infinity);\n  const parents = Array(grid.length * nCols).fill(null);\n  // to stop earlier\n  let stop = true;\n  // i: number of edges allowed\n  // for i =0, all dist from s to vertex are infinity\n  // dist s to s\n  distances[start.val] = 0;\n  // i edges allowed, (n-1) at most => O(n)\n  // try for n edges to check for negative cycles\n  // if costs get smaller indefinitely (OPT(n,v) !== OPT(n-1,v))\n  // There is a negative cycle\n  for (let i = 1; i < grid.length * nCols; i++) {\n    clearPathAnimation(grid);\n    // if any distance get smaller, we can stop early\n    // if after n-1 steps: the costs still get smaller (with n edges allowed)\n    // negative cycle detected!\n    stop = true;\n    // try a min path for each edge => O(m)\n    for (let val = 0; val < grid.length * nCols; val++) {\n      const [r, c] = valToIndx(val, nCols);\n      const v = grid[r][c];\n      // only try for distances that can be decreased\n      if (distances[val] === Infinity || v.isWall) {\n        continue;\n      }\n      for (let k in v.adjList) {\n        const neighbour = v.adjList[k];\n        // check if is not null => grid border\n        if (neighbour !== null) {\n          const [row, col] = valToIndx(neighbour, nCols);\n          //   neighbour as a vertex\n          let nextVertex = grid[row][col];\n          if (!nextVertex.isWall) {\n            let d = distances[val] + nextVertex.w;\n            // vertex checked\n            await visitedAnimation(neighbour, start.val, end.val, \"#c5c9ca\");\n            //   to check if is not wall\n            if (d < distances[neighbour]) {\n              distances[neighbour] = d;\n              parents[neighbour] = val;\n              // still getting costs update => dont stop!\n              stop = false;\n              // vertex with cost decreased\n              await visitedAnimation(neighbour, start.val, end.val);\n            }\n          }\n        }\n      }\n    }\n    if (stop) break;\n  }\n  if (!stop) {\n    alert(\"Negative Cycle was found!\");\n  }\n\n  console.log(`cycle: ${!stop}`);\n  if (parents[end.val] && stop) {\n    const path = getWeightedPath(parents, start.val, end.val);\n    await pathAnimation(path, start.val);\n  }\n};\n\nexport default bellmanFord;\n","class Node {\n  constructor(key, val) {\n    this.key = key;\n    this.val = val;\n  }\n}\n\nclass Heap {\n  constructor() {\n    this.values = [];\n    // dict: key to array idx => you say the key it returns the idx\n    this.idxs = {};\n  }\n\n  //   return true if this heap constains this key\n  //   otherwise returns false\n  contains(key) {\n    if (this.values[this.idxs[key]] === undefined) return false;\n    return true;\n  }\n\n  // return true if the element from index i is smaller than k idx element\n  lessThan(i, k) {\n    // out of bounds\n    if (i < 0 || k < 0) return false;\n    if (i > this.values.length - 1 || k > this.values.length - 1) return false;\n    let val = this.values[i].val;\n    let parent = this.values[k].val;\n    if (val < parent) return true;\n    return false;\n  }\n\n  //   return the parent's index of the ith node\n  myParentIdx(i) {\n    return Math.floor((i - 1) / 2);\n  }\n\n  //   return the children's index of the ith node\n  myChildrenIdx(i) {\n    // left 2 * i + 1 , right 2 * idx + 2\n    return [2 * i + 1, 2 * i + 2];\n  }\n\n  bubbleUp(i, j) {\n    //swap i and j\n    [this.values[i], this.values[j]] = [this.values[j], this.values[i]];\n\n    // swap idxs elements in dict key to idx\n    [this.idxs[this.values[i].key], this.idxs[this.values[j].key]] = [\n      this.idxs[this.values[j].key],\n      this.idxs[this.values[i].key],\n    ];\n  }\n\n  //   also returns the smmaller child idx\n  bubbleDown(idx, l, r) {\n    let smallIdx;\n    if (this.lessThan(l, r)) {\n      smallIdx = l;\n    } else if (this.lessThan(r, l)) {\n      smallIdx = r;\n    } else {\n      smallIdx = l;\n    }\n    // swap element from idx with greater\n    [this.values[idx], this.values[smallIdx]] = [\n      this.values[smallIdx],\n      this.values[idx],\n    ];\n\n    // swap idxs elements in dict key to idx\n    [this.idxs[this.values[idx].key], this.idxs[this.values[smallIdx].key]] = [\n      this.idxs[this.values[smallIdx].key],\n      this.idxs[this.values[idx].key],\n    ];\n\n    return smallIdx;\n  }\n\n  // insert an element in the next free spot and rearrange\n  //   return Heap\n  enqueue(key, val) {\n    // check whether this val belongs to this heap\n    // to avoid duplicate keys\n    if (this.contains(key)) return false;\n    let node = new Node(key, val);\n    this.values.push(node);\n    // last position to insert this new node\n    let idx = this.values.length - 1;\n    // add the idx of this key on the dict\n    this.idxs[key] = idx;\n    let parentIdx = this.myParentIdx(idx);\n    // bubble-up (while this new node is smaller than its parent)\n    while (this.lessThan(idx, parentIdx)) {\n      this.bubbleUp(idx, parentIdx);\n      //   recalculate node idx, parent idx position\n      idx = parentIdx;\n      parentIdx = this.myParentIdx(idx);\n    }\n    return this;\n  }\n\n  //   update val of this key and return this heap\n  //   if there is not any node with this key in this heap return false\n  decreaseKey(key, newVal) {\n    // check whether this key belongs to this heap\n    if (!this.contains(key)) return false;\n    //   get idx of this key\n    let idx = this.idxs[key];\n    //   update node with new val\n    this.values[idx].val = newVal;\n    let parentIdx = this.myParentIdx(idx);\n    if (parentIdx < 0) return this;\n    // bubble-up (while this new node is smaller than its parent)\n    while (this.lessThan(idx, parentIdx)) {\n      this.bubbleUp(idx, parentIdx);\n      //   recalculate node idx, parent idx position\n      idx = parentIdx;\n      parentIdx = this.myParentIdx(idx);\n    }\n    return this;\n  }\n\n  // Remove the root (min),\n  //   put the last element in the top and then rearrange\n  // return the root and the new arrangement\n  dequeue() {\n    // if is empty return undefined\n    if (this.values.length === 0) return undefined;\n    if (this.values.length === 1)\n      return { element: this.values.pop(), heap: this };\n    const min = this.values[0];\n    // replace the root with the last element\n    this.values[0] = this.values.pop();\n    // delete from dict\n    delete this.idxs[min.key];\n    // update idx of the 'new root' in the dict\n    this.idxs[this.values[0].key] = 0;\n    // index of this node we have to rearrange and the idx of its children\n    let idx = 0;\n    let [lChild, rChild] = this.myChildrenIdx(idx);\n    // bubble-down (while any child is smaller than the parent)\n    while (this.lessThan(lChild, idx) || this.lessThan(rChild, idx)) {\n      // update idx and its children\n      idx = this.bubbleDown(idx, lChild, rChild);\n      [lChild, rChild] = this.myChildrenIdx(idx);\n    }\n    return { element: min, heap: this };\n  }\n}\n\nexport default Heap;\n","import Heap from \"../structures/heap\";\nimport {\n  valToIndx,\n  getWeightedPath,\n  manhattan,\n} from \"../helpers/gridPropertiesHelper\";\nimport { pathAnimation, visitedAnimation } from \"../animations\";\n\nconst a = async (grid, start, end, nCols, wRange, alpha) => {\n  const heap = new Heap();\n  // expected value of a random (uniformily) weight :\n  //    sum of all possible values <sum of N first terms of AP> / max value\n  const SCALING_FACTOR = ((wRange + 1) * (wRange / 2)) / wRange;\n  // Initialize distances with Infinity and parents array with null\n  // Distance between any given node to the start node\n  const distances = Array(grid.length * nCols).fill(Infinity);\n  const parents = Array(grid.length * nCols).fill(null);\n  let smallestVal, found;\n  let inspectedNodes = 0;\n  let decrease = false;\n  let nDeq = 0;\n  distances[start.val] = 0;\n  //   add the start node to the heap\n  //   we will use f(n) = alpha * distance + ( 1 - alpha) * Manhattan distance\n  // as val to be minimized in the heap\n  //   f for the start node\n  heap.enqueue(start.val, f(0, start, end, alpha));\n  inspectedNodes++;\n\n  //   while there are elements in this heap\n  while (heap.values.length) {\n    //   get the min value from the heap\n    let s = heap.dequeue().element;\n    nDeq++;\n    // get its vertex\n    smallestVal = s.key;\n    // check if we find the target node\n    if (smallestVal === end.val) {\n      found = true;\n      break;\n    }\n    // convert smallestVal to a Vertex\n    const [r, c] = valToIndx(smallestVal, nCols);\n    const smallest = grid[r][c];\n    // for all neighbour of smallest\n    for (let k in smallest.adjList) {\n      // get the val of the neighbour\n      const neighbour = smallest.adjList[k];\n      // check if is not null => grid border\n      if (neighbour !== null) {\n        const [row, col] = valToIndx(neighbour, nCols);\n        //   neighbour as a vertex\n        let nextVertex = grid[row][col];\n        // calculate Dijkstra's  Greedy Criterium and manhattan distance\n        let d = distances[smallestVal] + smallest.w;\n        let newF = f(d, nextVertex, end, alpha, SCALING_FACTOR);\n        let oldF = f(\n          distances[nextVertex.val],\n          nextVertex,\n          end,\n          alpha,\n          SCALING_FACTOR\n        );\n        //   compare f(d,next,end) with f calculated with last distance storaged\n        if (newF < oldF && !nextVertex.isWall) {\n          //   updating distances and parents\n          distances[nextVertex.val] = d;\n          parents[nextVertex.val] = smallest.val;\n          decrease = heap.decreaseKey(nextVertex.val, newF);\n          if (!decrease) {\n            // enqueue with new priority\n            heap.enqueue(nextVertex.val, newF);\n          }\n          await visitedAnimation(nextVertex.val, start.val, end.val);\n          inspectedNodes++;\n        }\n      }\n    }\n  }\n  if (!found) return;\n  const path = getWeightedPath(parents, start.val, end.val);\n  //   min distance g() found  by A*\n  console.log(`A* with Alpha= ${alpha} Min Distance = ${distances[end.val]}`);\n  //   distance of this path (yellow)\n  console.log(\n    `A* with Alpha= ${alpha} Distance Calculated = ${getPathDistance(\n      path,\n      grid,\n      start,\n      nCols\n    )}`\n  );\n  console.log(`A* with Alpha= ${alpha} inspectedNodes = ${inspectedNodes}`);\n  console.log(`A* with Alpha= ${alpha} Dequeues = ${nDeq}`);\n  console.log(`scaling factor: ${SCALING_FACTOR}`);\n  await pathAnimation(path, start.val);\n};\n\n//   we will use f(n) = (alpha * distance + ( 1 - alpha) * Manhattan distance) * SCALING FACTOR\n//      we use a scaling factor because we compare nodes' weights with distances\n//      weight: [1, wRange] ; while Manhattan d. is calculated in '[nodes distance] units': 1 (for adj nodes)\n// as val to be minimized in the heap\nconst f = (distance, a, b, alpha, sf) => {\n  const g = distance;\n  const h = manhattan(a.row, b.row, a.col, b.col) * sf;\n  const w = g === Infinity && alpha === 0 ? Infinity : alpha * g;\n  const z = (1 - alpha) * h;\n  return w + z;\n};\n\nconst getPathDistance = (path, grid, start, nCols) => {\n  // start and finish nodes are not in the path (yelow animation)\n  let d = start.w;\n  for (let i = 0; i < path.length; i++) {\n    let [r, c] = valToIndx(path[i], nCols);\n    const node = grid[r][c];\n    d += node.w;\n  }\n  return d;\n};\nexport default a;\n","// TODO: Refactoring Drawer and btns\nimport React, { Fragment, useState } from \"react\";\nimport \"rc-slider/assets/index.css\";\nimport bfs from \"./algorithms/bfs\";\nimport dfs from \"./algorithms/dfs\";\nimport a from \"./algorithms/a\";\nimport bellmanFord from \"./algorithms/bellmanFord\";\nimport { clearAnimation, clearPathAnimation } from \"./animations\";\nimport Dialog from \"@material-ui/core/Dialog\";\nimport DialogActions from \"@material-ui/core/DialogActions\";\nimport DialogContent from \"@material-ui/core/DialogContent\";\nimport DialogContentText from \"@material-ui/core/DialogContentText\";\nimport DialogTitle from \"@material-ui/core/DialogTitle\";\n\nimport Slider from \"rc-slider\";\nimport AppBar from \"@material-ui/core/AppBar\";\nimport useMediaQuery from \"@material-ui/core/useMediaQuery\";\nimport { useTheme } from \"@material-ui/core/styles\";\nimport Toolbar from \"@material-ui/core/Toolbar\";\nimport Button from \"@material-ui/core/Button\";\nimport Typography from \"@material-ui/core/Typography\";\nimport SwipeableDrawer from \"@material-ui/core/SwipeableDrawer\";\nimport IconButton from \"@material-ui/core/IconButton\";\nimport MenuIcon from \"@material-ui/icons/Menu\";\nimport List from \"@material-ui/core/List\";\nimport ListItem from \"@material-ui/core/ListItem\";\nimport ListItemText from \"@material-ui/core/ListItemText\";\n\nimport styles from \"./NavStyles\";\nimport { valToIndx, getNewMazedGrid } from \"./helpers/gridPropertiesHelper\";\nimport { getInitialGrid } from \"./helpers/initialGridHelper\";\n\nconst MIN = -5;\n\nfunction Nav(props) {\n  const {\n    grid,\n    disable,\n    start,\n    end,\n    setGrid,\n    setDisable,\n    nRows,\n    nCols,\n    wRange,\n    isWeighted,\n    setIsWeighted,\n    toggleIsweighted,\n    isNegative,\n    toggleIsNegative,\n    handleChangeStart,\n    handleChangeFinish,\n  } = props;\n\n  const classes = styles();\n  const theme = useTheme();\n  const matchesSM = useMediaQuery(theme.breakpoints.down(\"sm\"));\n  const [openDrawer, setOpenDrawer] = useState(false);\n  const iOS = process.browser && /iPad|iPhone|iPod/.test(navigator.userAgent);\n\n  const [rowEnd, colEnd] = valToIndx(end, nCols);\n  const [rowStart, colStart] = valToIndx(start, nCols);\n  const [alpha, setAlpha] = useState(0.57);\n  const [fName, setFName] = useState(\"A*\");\n  const [openAlert, setOpenAlert] = useState(false);\n\n  const handleClickOpenAlert = () => {\n    setOpenAlert(true);\n  };\n\n  const handleCloseAlert = () => {\n    setOpenAlert(false);\n  };\n\n  const changeAlpha = (alpha) => setAlpha(alpha);\n\n  const clear = () => {\n    clearAnimation(grid, start, end);\n    const n = getInitialGrid(start, end, nRows, nCols, wRange);\n    setGrid(n);\n    setIsWeighted(false);\n  };\n\n  const newMaze = async () => {\n    const newGrid = await getNewMazedGrid(grid, 0.33);\n    setGrid(newGrid);\n  };\n\n  const negativeWeight = () => {\n    clearAnimation(grid, start, end);\n    let n;\n    if (!isNegative) {\n      n = getInitialGrid(start, end, nRows, nCols, wRange, MIN);\n    } else {\n      n = getInitialGrid(start, end, nRows, nCols, wRange);\n    }\n    setGrid(n);\n    setIsWeighted(true);\n    toggleIsNegative();\n  };\n\n  const handleClick = async (alg) => {\n    setDisable(true);\n    await alg;\n    setDisable(false);\n  };\n\n  const hanldeSliderChange = () => {\n    if (alpha !== 0 && alpha !== 1) setFName(\"A*\");\n    else {\n      if (alpha === 0) setFName(\"Best Fisrt Search\");\n      if (alpha === 1) setFName(\"Dijkstra\");\n    }\n  };\n\n  const btnOptList = [\n    { name: \"Clear\", click: () => clear(), disabled: disable },\n    {\n      name: \"Clear Path\",\n      click: () => clearPathAnimation(grid),\n      disabled: disable,\n    },\n    { name: \"Maze\", click: () => handleClick(newMaze()), disabled: disable },\n    {\n      name: \"Change Start\",\n      click: () => handleChangeStart(),\n      disabled: disable,\n    },\n    {\n      name: \"Change Target\",\n      click: () => handleChangeFinish(),\n      disabled: disable,\n    },\n    {\n      name: isWeighted ? \"Unweighted Grid\" : \"Weighted Grid\",\n      click: () => handleClick(toggleIsweighted()),\n      disabled: disable,\n    },\n    {\n      name: isNegative ? \"Positive\" : \"Negative\",\n      click: negativeWeight,\n      disabled: disable,\n    },\n  ];\n\n  const unWBtnsList = [\n    {\n      name: \"BFS\",\n      click: () =>\n        handleClick(\n          bfs(grid, grid[rowStart][colStart], grid[rowEnd][colEnd], nCols)\n        ),\n      disabled: isWeighted ? true : disable,\n    },\n    {\n      name: \"DFS\",\n      click: () =>\n        handleClick(\n          dfs(grid, grid[rowStart][colStart], grid[rowEnd][colEnd], nCols)\n        ),\n      disabled: isWeighted ? true : disable,\n    },\n  ];\n\n  const btnOpts = (\n    <Fragment>\n      {btnOptList.map((btn) => (\n        <Button\n          key={`btnOpt-${btn.name}`}\n          className={classes.button}\n          onClick={btn.click}\n          disabled={btn.disabled}\n        >\n          {btn.name}\n        </Button>\n      ))}\n    </Fragment>\n  );\n\n  const unWBtns = (\n    <Fragment>\n      {unWBtnsList.map((btn) => (\n        <Button\n          key={`unWBtn-${btn.name}`}\n          className={classes.button}\n          onClick={btn.click}\n          disabled={btn.disabled}\n        >\n          <Typography className={classes.text}>{btn.name}</Typography>\n        </Button>\n      ))}\n    </Fragment>\n  );\n\n  const wBtns = (\n    <Fragment>\n      <div className={classes.slider}>\n        <Slider\n          defaultValue={alpha}\n          min={0}\n          max={1}\n          onAfterChange={hanldeSliderChange}\n          onChange={changeAlpha}\n          step={0.01}\n          disabled={disable}\n        />\n      </div>\n      <span className={classes.text}>Alpha: {alpha}</span>\n      <Button\n        className={classes.button}\n        onClick={() =>\n          handleClick(\n            a(\n              grid,\n              grid[rowStart][colStart],\n              grid[rowEnd][colEnd],\n              nCols,\n              wRange,\n              alpha\n            )\n          )\n        }\n        disabled={disable}\n      >\n        {fName}\n      </Button>\n    </Fragment>\n  );\n\n  const negBtns = (\n    <Fragment>\n      <Button\n        onClick={handleClickOpenAlert}\n        disabled={disable}\n        className={classes.button}\n      >\n        <Typography className={classes.text}>Bellman-Ford</Typography>\n      </Button>\n      <Dialog\n        open={openAlert}\n        onClose={handleCloseAlert}\n        aria-labelledby=\"alert-dialog-title\"\n        aria-describedby=\"alert-dialog-description\"\n      >\n        <DialogTitle id=\"alert-dialog-title\">\n          How to run Bellman-Ford?\n        </DialogTitle>\n        <DialogContent>\n          <DialogContentText id=\"alert-dialog-description\">\n            * Recommended Mode: Will Clear Grid, add to layers of walls and then\n            run Bellman-Ford. PS: Put both start and finsih node in the same\n            connected component is necessary for search min Path.\n          </DialogContentText>\n          <DialogContentText>\n            * Free-Style: Won't change any grid property and you can run as you\n            want.\n          </DialogContentText>\n        </DialogContent>\n        <DialogActions>\n          <Button\n            onClick={async () => {\n              handleCloseAlert();\n              clear();\n              await newMaze();\n              await newMaze();\n              setIsWeighted(true);\n              handleClick(\n                bellmanFord(\n                  grid,\n                  grid[rowStart][colStart],\n                  grid[rowEnd][colEnd],\n                  nCols\n                )\n              );\n            }}\n            color=\"primary\"\n          >\n            Recommended\n          </Button>\n          <Button\n            onClick={async () => {\n              handleCloseAlert();\n              handleClick(\n                bellmanFord(\n                  grid,\n                  grid[rowStart][colStart],\n                  grid[rowEnd][colEnd],\n                  nCols\n                )\n              );\n            }}\n            color=\"primary\"\n            autoFocus\n          >\n            Free-Style\n          </Button>\n        </DialogActions>\n      </Dialog>\n    </Fragment>\n  );\n\n  const btns = (\n    <Fragment>\n      <div className={classes.btnOpt}> {btnOpts}</div>\n      <div>{isWeighted ? null : unWBtns}</div>\n      <div>{!isWeighted ? null : isNegative ? negBtns : wBtns}</div>\n      <Button\n        className={classes.button}\n        onClick={() => {\n          window.open(\n            \"https://github.com/LyangHiga/pathfinding-visualizer#instructions\",\n            \"_blank\"\n          );\n        }}\n      >\n        Instructions\n      </Button>\n    </Fragment>\n  );\n\n  const drawer = (\n    <Fragment>\n      <SwipeableDrawer\n        disableBackdropTransition={!iOS}\n        disableDiscovery={iOS}\n        open={openDrawer}\n        onClose={() => setOpenDrawer(false)}\n        onOpen={() => setOpenDrawer(true)}\n      >\n        <List disablePadding>\n          {btnOptList.map((btn) => (\n            <ListItem\n              key={`list-${btn.name}`}\n              onClick={() => {\n                setOpenDrawer(false);\n                btn.click();\n              }}\n              divider\n              button\n              className={classes.button}\n              disabled={disable}\n            >\n              <ListItemText>{btn.name}</ListItemText>\n            </ListItem>\n          ))}\n        </List>\n        {isWeighted ? (\n          !isNegative ? (\n            <List disablePadding>\n              <ListItem divider>\n                <Slider\n                  defaultValue={alpha}\n                  min={0}\n                  max={1}\n                  onAfterChange={hanldeSliderChange}\n                  onChange={changeAlpha}\n                  step={0.01}\n                  disabled={disable}\n                  className={classes.slider}\n                />\n              </ListItem>\n              <ListItem divider className={classes.button}>\n                <ListItemText>Alpha: {alpha}</ListItemText>\n              </ListItem>\n              <ListItem\n                onClick={() => {\n                  setOpenDrawer(false);\n                  handleClick(\n                    a(\n                      grid,\n                      grid[rowStart][colStart],\n                      grid[rowEnd][colEnd],\n                      nCols,\n                      wRange,\n                      alpha\n                    )\n                  );\n                }}\n                divider\n                button\n                className={classes.button}\n                disabled={disable}\n              >\n                <ListItemText>{fName}</ListItemText>\n              </ListItem>\n            </List>\n          ) : (\n            <List disablePadding>\n              <ListItem\n                onClick={handleClickOpenAlert}\n                divider\n                button\n                className={classes.button}\n                disabled={disable}\n              >\n                <ListItemText>Bellman-Ford</ListItemText>\n              </ListItem>\n              <Dialog\n                open={openAlert}\n                onClose={handleCloseAlert}\n                aria-labelledby=\"alert-dialog-title\"\n                aria-describedby=\"alert-dialog-description\"\n              >\n                <DialogTitle id=\"alert-dialog-title\">\n                  How to run Bellman-Ford?\n                </DialogTitle>\n                <DialogContent>\n                  <DialogContentText id=\"alert-dialog-description\">\n                    * Recommended Mode: Will Clear Grid, add to layers of walls\n                    and then run Bellman-Ford. PS: Put both start and finsih\n                    node in the same connected component is necessary for search\n                    min Path.\n                  </DialogContentText>\n                  <DialogContentText>\n                    * Free-Style: Won't change any grid property and you can run\n                    as you want.\n                  </DialogContentText>\n                </DialogContent>\n                <DialogActions>\n                  <Button\n                    onClick={async () => {\n                      setOpenDrawer(false);\n                      handleCloseAlert();\n                      clear();\n                      await newMaze();\n                      await newMaze();\n                      setIsWeighted(true);\n                      handleClick(\n                        bellmanFord(\n                          grid,\n                          grid[rowStart][colStart],\n                          grid[rowEnd][colEnd],\n                          nCols\n                        )\n                      );\n                    }}\n                    color=\"primary\"\n                  >\n                    Recommended\n                  </Button>\n                  <Button\n                    onClick={async () => {\n                      setOpenDrawer(false);\n                      handleCloseAlert();\n                      handleClick(\n                        bellmanFord(\n                          grid,\n                          grid[rowStart][colStart],\n                          grid[rowEnd][colEnd],\n                          nCols\n                        )\n                      );\n                    }}\n                    color=\"primary\"\n                    autoFocus\n                  >\n                    Free-Style\n                  </Button>\n                </DialogActions>\n              </Dialog>\n            </List>\n          )\n        ) : (\n          <List disablePadding>\n            {unWBtnsList.map((btn) => (\n              <ListItem\n                key={`list-${btn.name}`}\n                onClick={() => {\n                  setOpenDrawer(false);\n                  btn.click();\n                }}\n                divider\n                button\n                className={classes.button}\n                disabled={disable}\n              >\n                <ListItemText>{btn.name}</ListItemText>\n              </ListItem>\n            ))}\n          </List>\n        )}\n        <List>\n          <ListItem\n            divider\n            className={classes.button}\n            onClick={() => {\n              window.open(\n                \"https://github.com/LyangHiga/pathfinding-visualizer#instructions\",\n                \"_blank\"\n              );\n            }}\n          >\n            <ListItemText>Instructions</ListItemText>\n          </ListItem>\n        </List>\n      </SwipeableDrawer>\n      <IconButton\n        className={classes.drawerIconContainer}\n        onClick={() => setOpenDrawer(!openDrawer)}\n        disableRipple\n      >\n        <MenuIcon></MenuIcon>\n      </IconButton>\n    </Fragment>\n  );\n\n  return (\n    <AppBar position=\"static\" color=\"inherit\" className={classes.Navbar}>\n      <Toolbar>\n        <Typography className={classes.title} variant=\"h6\" color=\"inherit\">\n          Pathfinding Visualizer\n        </Typography>\n        {matchesSM ? drawer : btns}\n      </Toolbar>\n    </AppBar>\n  );\n}\n\nexport default Nav;\n","import { makeStyles } from \"@material-ui/core/styles\";\n\nconst styles = makeStyles((theme) => ({\n  Navbar: {\n    height: \"8vh\",\n    marginBottom: \"10px\",\n    [theme.breakpoints.down(\"sm\")]: {\n      height: \"10vh\",\n    },\n  },\n  title: {\n    [theme.breakpoints.up(\"md\")]: {\n      marginRight: \"1vw\",\n      paddingRight: \"2vw\",\n      borderRight: \"1px solid black\",\n      padding: \"0.5em\",\n    },\n  },\n  btnOpt: {\n    marginRight: \"1vw\",\n    paddingRight: \"1vw\",\n    borderRight: \"1px solid black\",\n    padding: \"0.5em\",\n    [theme.breakpoints.down(\"md\")]: {\n      marginRight: \"0.7vw\",\n      paddingRight: \"1.6vw\",\n      borderRight: \"1px solid black\",\n      padding: \"0.3em\",\n    },\n  },\n  button: {\n    margin: \"0 6px\",\n    fontSize: \"1rem\",\n    textTransform: \"none\",\n    [theme.breakpoints.down(\"md\")]: {\n      margin: \"0 4px\",\n      fontSize: \"0.8rem\",\n      textTransform: \"none\",\n    },\n  },\n  slider: {\n    width: \"12vw\",\n    margin: \"0 10px\",\n    [theme.breakpoints.down(\"md\")]: {\n      width: \"8vw\",\n      margin: \"0 6px\",\n    },\n    [theme.breakpoints.down(\"sm\")]: {\n      width: \"100%\",\n      margin: 0,\n    },\n    display: \"inline-block\",\n    \"& .rc-slider-track\": {\n      backgroundColor: \"transparent\",\n    },\n    \"& .rc-slider-rail\": {\n      height: \"8px\",\n    },\n    \"& .rc-slider-handle:active, .rc-slider-handle:hover, .rc-slider-handle:focus, .rc-slider-handle\": {\n      backgroundColor: \"black\",\n      outline: \"none\",\n      border: \"2px solid black\",\n      boxShadow: \"none\",\n      width: \"13px\",\n      height: \"13px\",\n      marginLeft: \"-7px\",\n      marginTop: \"-3px\",\n    },\n  },\n  drawerIconContainer: {\n    marginLeft: \"auto\",\n    \"&:hover\": {\n      backgroundColor: \"transparent\",\n    },\n  },\n  text: {\n    fontSize: \"1em\",\n    [theme.breakpoints.down(\"md\")]: {\n      fontSize: \"0.8rem\",\n    },\n  },\n}));\n\nexport default styles;\n","// linked list Node\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n// Queue implementation, FIFO, through linked list\nclass Queue {\n  constructor() {\n    this.first = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  // add to the end and return the size of this queue\n  enQueue(val) {\n    let node = new Node(val);\n    if (this.size === 0) {\n      this.first = node;\n      this.last = node;\n    } else {\n      this.last.next = node;\n      this.last = node;\n    }\n    this.size++;\n    return this.size;\n  }\n\n  // remove the first node and return it\n  deQueue() {\n    if (this.size === 0) return null;\n    let removed = this.first;\n    if (this.size === 1) {\n      this.first = null;\n      this.last = null;\n    } else {\n      this.first = removed.next;\n      removed.next = null;\n    }\n    this.size--;\n    return removed;\n  }\n}\n\nexport default Queue;\n","import Queue from '../structures/queue';\nimport { valToIndx, getPath } from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst bfs = async (grid, start, end, nCols) => {\n  let visited = {};\n  let parents = {};\n  let dist = {};\n  let q = new Queue();\n  // add start vertex to the queue\n  q.enQueue(start);\n  // start vertex is already visited\n  visited[start.val] = true;\n  dist[start.val] = 0;\n  parents[start.val] = null;\n  // vertex that will be deQueue\n  let v;\n  while (q.size !== 0) {\n    v = q.deQueue().val;\n    // check if v is the end vertex\n    if (v.val === end.val) {\n      //   we find the target\n      break;\n    }\n    // for every edge of v\n    for (const key in v.adjList) {\n      const w = v.adjList[key];\n      const [row, col] = valToIndx(w, nCols);\n      //   wVertex has all properties while w is wVeterx.val\n      const wVertex = grid[row][col];\n      //   check w is visited, is not null or wall\n      if (visited[w] !== true && w !== null && !wVertex.isWall) {\n        //mark  w as visited\n        visited[w] = true;\n        await visitedAnimation(w, start.val, end.val);\n        //   enQueue vertex w\n        q.enQueue(wVertex);\n        parents[w] = v.val;\n        dist[w] = dist[v.val] + 1;\n      }\n    }\n  }\n  const path = getPath(parents, end.val, dist[end.val]);\n  await pathAnimation(path, start.val);\n};\n\nexport default bfs;\n","// linked list Node\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n// simple implementation using SLL, shift and unshift, here called as push and pop\n// First in Last Out\nclass Stack {\n  constructor() {\n    this.first = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  // add a node at the beginning and return the size of this stack\n  push(val) {\n    let node = new Node(val);\n    if (this.size === 0) {\n      this.first = node;\n      this.last = node;\n    } else {\n      node.next = this.first;\n      this.first = node;\n    }\n    this.size++;\n    return this.size;\n  }\n  // remove the first node and return it\n  pop() {\n    // empty stack\n    if (this.size === 0) return null;\n    let removed = this.first;\n    if (this.size === 1) {\n      this.first = null;\n      this.last = null;\n    } else {\n      this.first = removed.next;\n      removed.next = null;\n    }\n    this.size--;\n    return removed;\n  }\n}\n\nexport default Stack;\n","import Stack from '../structures/stack';\nimport { valToIndx } from '../helpers/gridPropertiesHelper';\nimport { visitedAnimation } from '../animations';\n\nconst dfs = async (grid, start, end, nCols) => {\n  //   const end = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n  //   stack pop order\n  let result = [];\n  let visited = {};\n  let stack = new Stack();\n  // add start vertex to the stack\n  stack.push(start);\n  // start vertex is already visited\n  visited[start.val] = true;\n  let v;\n  while (stack.size !== 0) {\n    // take vertex v from the top of the stack\n    v = stack.pop().val;\n    result.push(v.val);\n    if (v.val === end.val) {\n      //   we find the target\n      break;\n    }\n    // mark w as visited\n    visited[v.val] = true;\n    await visitedAnimation(v.val, start.val, end.val);\n    // for every edge of v\n    for (const key in v.adjList) {\n      const w = v.adjList[key];\n      const [row, col] = valToIndx(w, nCols);\n      //   wVertex has all properties while w is wVeterx.val\n      const wVertex = grid[row][col];\n      //   check w is visited, is not null or wall\n      if (visited[w] !== true && w !== null && !wVertex.isWall) {\n        //   push w vertex\n        stack.push(wVertex);\n        if (w === end.val) {\n          //   we find the target\n          break;\n        }\n      }\n    }\n  }\n};\n\nexport default dfs;\n"],"sourceRoot":""}