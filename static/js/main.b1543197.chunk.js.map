{"version":3,"sources":["Node.js","animations.js","helpers/gridPropertiesHelper.js","helpers/initialGridHelper.js","structures/queue.js","algorithms/bfs.js","structures/stack.js","algorithms/dfs.js","structures/heap.js","algorithms/a.js","NavStyles.js","Nav.js","hooks/useToggleState.js","PathFindingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","id","val","className","onMouseDown","row","col","onMouseEnter","onMouseUp","isWeighted","w","sleep","m","Promise","r","setTimeout","pathAnimation","path","a","i","length","changingPropAnimation","visitedAnimation","start","end","color","document","getElementById","style","backgroundColor","wallAnimation","v","isStart","isFinish","startNodeAnimation","finishNodeAnimation","clearNodeAnimation","valToIndx","nCols","Math","floor","getNewGridWithNewProperty","grid","prop","newGrid","slice","c","oldNode","oldPropToggled","toggleNodeProperty","node","newNode","getNewGridWithWallToggled","isWall","getNewMazedGrid","eps","random","getPath","parents","dist","push","console","log","reverse","getWeightedPath","getRowsCols","width","window","innerWidth","documentElement","clientWidth","body","height","innerHeight","clientHeight","getRandomVertex","nRows","createNode","finish","adjList","createAdjList","b","d","getInitialGrid","wRange","currentRow","this","next","Queue","first","last","size","removed","bfs","visited","q","enQueue","deQueue","key","wVertex","Stack","dfs","result","stack","pop","Heap","values","idxs","undefined","k","j","idx","l","smallIdx","lessThan","contains","parentIdx","myParentIdx","bubbleUp","newVal","element","heap","min","myChildrenIdx","lChild","rChild","bubbleDown","alpha","SCALING_FACTOR","distances","Array","fill","Infinity","inspectedNodes","nDeq","enqueue","f","s","dequeue","smallestVal","found","smallest","neighbour","nextVertex","newF","oldF","decreaseKey","getPathDistance","distance","sf","abs","manhattan","styles","makeStyles","Navbar","display","alignItems","justifyContent","marginBottom","title","button","margin","fontSize","textTransform","slider","outline","border","boxShadow","marginLeft","marginTop","Nav","disable","setGrid","setDisable","setIsWeighted","toggleIsweighted","clear","startVal","finishVal","clearAnimation","n","newMaze","handleClick","alg","rowEnd","colEnd","rowStart","colStart","useState","setAlpha","fName","setFName","classes","AppBar","position","Toolbar","Typography","variant","Button","onClick","disabled","vertex","clearPathAnimation","defaultValue","max","onAfterChange","onChange","step","open","useToggleState","initialVal","state","setState","toggle","PathFindingVisualizer","setNRows","setNCols","startVertex","setStarteVertex","finishVertex","setFinishVertex","mouseIsPressed","setMouseIsPressed","createWall","setCreatWall","toggleCreateWall","changeStart","setChangeStart","toggleChangeStart","changeFinish","setChangeFinish","toggleChangeFinish","useEffect","initialGrid","handleMouseDown","getNewGridWitNewStart","getNewGridWitNewFinish","handleMouseEnter","handleMouseUp","onKeyDown","event","tabIndex","map","rowIdx","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.b1543197.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.css';\n\nexport default function Node(props) {\n  return (\n    <div\n      id={`node-${props.val}`}\n      className={'node'}\n      onMouseDown={() => props.onMouseDown(props.row, props.col)}\n      onMouseEnter={() => props.onMouseEnter(props.row, props.col)}\n      onMouseUp={() => props.onMouseUp()}\n    >\n      {props.isWeighted ? <span>{props.w}</span> : ''}\n    </div>\n  );\n}\n","export const sleep = (m) => new Promise((r) => setTimeout(r, m));\n\nexport const pathAnimation = async (path) => {\n  for (let i = 0; i < path.length; i++) {\n    await sleep(12);\n    changingPropAnimation(path[i], 'yellow');\n  }\n};\n\nexport const visitedAnimation = async (val, start, end) => {\n  if (val === end) return;\n  if (val === start) return;\n  await sleep(7);\n  changingPropAnimation(val, 'blue');\n};\n\nexport const clearAnimation = (grid, startVal, finishVal) => {\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const v = grid[i][j];\n      changingPropAnimation(v.val, 'white');\n      if (v.val === startVal) {\n        changingPropAnimation(v.val, 'green');\n      }\n      if (v.val === finishVal) {\n        changingPropAnimation(v.val, 'red');\n      }\n    }\n  }\n};\n\nconst changingPropAnimation = (val, color) => {\n  const vertex = document.getElementById(`node-${val}`).style;\n  vertex.backgroundColor = `${color}`;\n};\n\nexport const wallAnimation = async (v) => {\n  if (v.isStart || v.isFinish) return;\n  await sleep(1);\n  changingPropAnimation(v.val, 'black');\n};\n\nexport const startNodeAnimation = (val) => {\n  changingPropAnimation(val, 'green');\n};\n\nexport const finishNodeAnimation = (val) => {\n  changingPropAnimation(val, 'red');\n};\n\nexport const clearNodeAnimation = (val) => {\n  changingPropAnimation(val, 'white');\n};\n\nexport const clearPathAnimation = (grid) => {\n  let vertex;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const v = grid[i][j];\n      vertex = document.getElementById(`node-${v.val}`).style;\n      if (\n        vertex.backgroundColor === 'blue' ||\n        vertex.backgroundColor === 'yellow'\n      ) {\n        clearNodeAnimation(v.val, 'white');\n      }\n    }\n  }\n};\n","import { wallAnimation } from '../animations';\n\n// Node Helpers\n\nexport const manhattan = (a, b, c, d) => {\n  return Math.abs(a - b) + Math.abs(c - d);\n};\n\n// returns {row, col} of a vertex val\nexport const valToIndx = (val, nCols) => {\n  const row = Math.floor(val / nCols);\n  const col = val - row * nCols;\n  return [row, col];\n};\n\n// Grid Helpers\n\nconst getNewGridWithNewProperty = (grid, row, col, prop, val, nCols) => {\n  const newGrid = grid.slice();\n  const [r, c] = valToIndx(val, nCols);\n  const oldNode = newGrid[r][c];\n  const oldPropToggled = toggleNodeProperty(oldNode, prop, false);\n  newGrid[r][c] = oldPropToggled;\n  const node = newGrid[row][col];\n  const newNode = toggleNodeProperty(node, prop, true);\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (wall is created)\nexport const getNewGridWithWallToggled = (grid, row, col) => {\n  if (grid[row][col].isStart || grid[row][col].isFinish) return grid;\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = toggleNodeProperty(node, 'isWall', !node.isWall);\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (new start node)\nexport const getNewGridWitNewStart = (grid, row, col, startVal, nCols) => {\n  const newGrid = getNewGridWithNewProperty(\n    grid,\n    row,\n    col,\n    'isStart',\n    startVal,\n    nCols\n  );\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (new finish point)\nexport const getNewGridWitNewFinish = (grid, row, col, finishVal, nCols) => {\n  const newGrid = getNewGridWithNewProperty(\n    grid,\n    row,\n    col,\n    'isFinish',\n    finishVal,\n    nCols\n  );\n  return newGrid;\n};\n\n// returns a new mazed grid\n// a node has eps prob to become a wall\nexport const getNewMazedGrid = async (grid, eps) => {\n  let newGrid = grid.slice();\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      if (grid[row][col].isStart || grid[row][col].isFinish) {\n        break;\n      }\n      if (Math.random() <= eps) {\n        const node = newGrid[row][col];\n        const newNode = toggleNodeProperty(node, 'isWall', true);\n        newGrid[row][col] = newNode;\n        await wallAnimation(newGrid[row][col]);\n      }\n    }\n  }\n  return newGrid;\n};\n\nconst toggleNodeProperty = (node, prop, val) => {\n  const newNode = {\n    ...node,\n    [prop]: val,\n  };\n  return newNode;\n};\n\n//   building path\nexport const getPath = (parents, end, dist) => {\n  let a = parents[end];\n  let path = [];\n  for (let i = 0; i < dist - 1; i++) {\n    path.push(a);\n    a = parents[a];\n  }\n  console.log(`Min Path: ${path.length + 1} squares`);\n  return path.reverse();\n};\n\n//   building path\nexport const getWeightedPath = (parents, start, end) => {\n  let a = parents[end];\n  let path = [];\n  while (a !== start) {\n    path.push(a);\n    a = parents[a];\n  }\n  return path.reverse();\n};\n\n// return number of rows and cols to display in this screen\nexport const getRowsCols = () => {\n  const width =\n    window.innerWidth ||\n    document.documentElement.clientWidth ||\n    document.body.clientWidth;\n  const height =\n    window.innerHeight ||\n    document.documentElement.clientHeight ||\n    document.body.clientHeight;\n  const nRows = Math.floor(width / 60);\n  const nCols = Math.floor(height / 15);\n  return [nRows, nCols];\n};\n","// import { NUM_COL, NUM_ROW } from '../consts';\n\n// returns a random vertex value\nexport const getRandomVertex = (nRows, nCols) => {\n  return Math.floor(Math.random() * nRows * nCols);\n};\n\nconst createNode = (col, row, start, finish, nRows, nCols, w = 1) => {\n  const val = row * nCols + col;\n  const adjList = createAdjList(val, col, row, nRows, nCols);\n\n  return {\n    col,\n    row,\n    isStart: val === start,\n    isFinish: val === finish,\n    isWall: false,\n    adjList: adjList,\n    val: val,\n    w,\n  };\n};\n\n//         A\n//    B   VAL  D\n//         C\n// returns all neighbours of VAL\nconst createAdjList = (val, col, row, nRows, nCols) => {\n  //   neighbours in a line above\n  // negative numbers arent a node\n  const a = row !== 0 ? val - nCols : null;\n  // neighbours in the same line\n  // check left border\n  const b = col !== 0 ? val - 1 : null;\n  // check right border\n  const d = col !== nCols - 1 ? val + 1 : null;\n  //  neighbours in a line bellow\n  // check overflow\n  const c = row !== nRows - 1 ? val + nCols : null;\n\n  return { a, b, c, d };\n};\n\n// returns the initial Grid\nexport const getInitialGrid = (start, finish, nRows, nCols, wRange = 0) => {\n  const grid = [];\n  for (let row = 0; row < nRows; row++) {\n    const currentRow = [];\n    for (let col = 0; col < nCols; col++) {\n      // get random weight for all edges of this node\n      const w = Math.floor(Math.random() * wRange + 1);\n      currentRow.push(createNode(col, row, start, finish, nRows, nCols, w));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n","// linked list Node\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n// Queue implementation, FIFO, through linked list\nclass Queue {\n  constructor() {\n    this.first = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  // add to the end and return the size of this queue\n  enQueue(val) {\n    let node = new Node(val);\n    if (this.size === 0) {\n      this.first = node;\n      this.last = node;\n    } else {\n      this.last.next = node;\n      this.last = node;\n    }\n    this.size++;\n    return this.size;\n  }\n\n  // remove the first node and return it\n  deQueue() {\n    if (this.size === 0) return null;\n    let removed = this.first;\n    if (this.size === 1) {\n      this.first = null;\n      this.last = null;\n    } else {\n      this.first = removed.next;\n      removed.next = null;\n    }\n    this.size--;\n    return removed;\n  }\n}\n\nexport default Queue;\n","import Queue from '../structures/queue';\nimport { valToIndx, getPath } from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst bfs = async (grid, start, end, nCols) => {\n  let visited = {};\n  let parents = {};\n  let dist = {};\n  let q = new Queue();\n  // add start vertex to the queue\n  q.enQueue(start);\n  // start vertex is already visited\n  visited[start.val] = true;\n  dist[start.val] = 0;\n  parents[start.val] = null;\n  // vertex that will be deQueue\n  let v;\n  while (q.size !== 0) {\n    v = q.deQueue().val;\n    // check if v is the end vertex\n    if (v.val === end.val) {\n      //   we find the target\n      break;\n    }\n    // for every edge of v\n    for (const key in v.adjList) {\n      const w = v.adjList[key];\n      const [row, col] = valToIndx(w, nCols);\n      //   wVertex has all properties while w is wVeterx.val\n      const wVertex = grid[row][col];\n      //   check w is visited, is not null or wall\n      if (visited[w] !== true && w !== null && !wVertex.isWall) {\n        //mark  w as visited\n        visited[w] = true;\n        await visitedAnimation(w, start.val, end.val);\n        //   enQueue vertex w\n        q.enQueue(wVertex);\n        parents[w] = v.val;\n        dist[w] = dist[v.val] + 1;\n      }\n    }\n  }\n  const path = getPath(parents, end.val, dist[end.val]);\n  await pathAnimation(path, start.val);\n};\n\nexport default bfs;\n","// linked list Node\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n// simple implementation using SLL, shift and unshift, here called as push and pop\n// First in Last Out\nclass Stack {\n  constructor() {\n    this.first = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  // add a node at the beginning and return the size of this stack\n  push(val) {\n    let node = new Node(val);\n    if (this.size === 0) {\n      this.first = node;\n      this.last = node;\n    } else {\n      node.next = this.first;\n      this.first = node;\n    }\n    this.size++;\n    return this.size;\n  }\n  // remove the first node and return it\n  pop() {\n    // empty stack\n    if (this.size === 0) return null;\n    let removed = this.first;\n    if (this.size === 1) {\n      this.first = null;\n      this.last = null;\n    } else {\n      this.first = removed.next;\n      removed.next = null;\n    }\n    this.size--;\n    return removed;\n  }\n}\n\nexport default Stack;\n","import Stack from '../structures/stack';\nimport { valToIndx } from '../helpers/gridPropertiesHelper';\nimport { visitedAnimation } from '../animations';\n\nconst dfs = async (grid, start, end, nCols) => {\n  //   const end = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n  //   stack pop order\n  let result = [];\n  let visited = {};\n  let stack = new Stack();\n  // add start vertex to the stack\n  stack.push(start);\n  // start vertex is already visited\n  visited[start.val] = true;\n  let v;\n  while (stack.size !== 0) {\n    // take vertex v from the top of the stack\n    v = stack.pop().val;\n    result.push(v.val);\n    if (v.val === end.val) {\n      //   we find the target\n      break;\n    }\n    // mark w as visited\n    visited[v.val] = true;\n    await visitedAnimation(v.val, start.val, end.val);\n    // for every edge of v\n    for (const key in v.adjList) {\n      const w = v.adjList[key];\n      const [row, col] = valToIndx(w, nCols);\n      //   wVertex has all properties while w is wVeterx.val\n      const wVertex = grid[row][col];\n      //   check w is visited, is not null or wall\n      if (visited[w] !== true && w !== null && !wVertex.isWall) {\n        //   push w vertex\n        stack.push(wVertex);\n        if (w === end.val) {\n          //   we find the target\n          break;\n        }\n      }\n    }\n  }\n};\n\nexport default dfs;\n","class Node {\n  constructor(key, val) {\n    this.key = key;\n    this.val = val;\n  }\n}\n\nclass Heap {\n  constructor() {\n    this.values = [];\n    // dict: key to array idx => you say the key it returns the idx\n    this.idxs = {};\n  }\n\n  //   return true if this heap constains this key\n  //   otherwise returns false\n  contains(key) {\n    if (this.values[this.idxs[key]] === undefined) return false;\n    return true;\n  }\n\n  // return true if the element from index i is smaller than k idx element\n  lessThan(i, k) {\n    // out of bounds\n    if (i < 0 || k < 0) return false;\n    if (i > this.values.length - 1 || k > this.values.length - 1) return false;\n    let val = this.values[i].val;\n    let parent = this.values[k].val;\n    if (val < parent) return true;\n    return false;\n  }\n\n  //   return the parent's index of the ith node\n  myParentIdx(i) {\n    return Math.floor((i - 1) / 2);\n  }\n\n  //   return the children's index of the ith node\n  myChildrenIdx(i) {\n    // left 2 * i + 1 , right 2 * idx + 2\n    return [2 * i + 1, 2 * i + 2];\n  }\n\n  bubbleUp(i, j) {\n    //swap i and j\n    [this.values[i], this.values[j]] = [this.values[j], this.values[i]];\n\n    // swap idxs elements in dict key to idx\n    [this.idxs[this.values[i].key], this.idxs[this.values[j].key]] = [\n      this.idxs[this.values[j].key],\n      this.idxs[this.values[i].key],\n    ];\n  }\n\n  //   also returns the smmaller child idx\n  bubbleDown(idx, l, r) {\n    let smallIdx;\n    if (this.lessThan(l, r)) {\n      smallIdx = l;\n    } else if (this.lessThan(r, l)) {\n      smallIdx = r;\n    } else {\n      smallIdx = l;\n    }\n    // swap element from idx with greater\n    [this.values[idx], this.values[smallIdx]] = [\n      this.values[smallIdx],\n      this.values[idx],\n    ];\n\n    // swap idxs elements in dict key to idx\n    [this.idxs[this.values[idx].key], this.idxs[this.values[smallIdx].key]] = [\n      this.idxs[this.values[smallIdx].key],\n      this.idxs[this.values[idx].key],\n    ];\n\n    return smallIdx;\n  }\n\n  // insert an element in the next free spot and rearrange\n  //   return Heap\n  enqueue(key, val) {\n    // check whether this val belongs to this heap\n    // to avoid duplicate keys\n    if (this.contains(key)) return false;\n    let node = new Node(key, val);\n    this.values.push(node);\n    // last position to insert this new node\n    let idx = this.values.length - 1;\n    // add the idx of this key on the dict\n    this.idxs[key] = idx;\n    let parentIdx = this.myParentIdx(idx);\n    // bubble-up (while this new node is smaller than its parent)\n    while (this.lessThan(idx, parentIdx)) {\n      this.bubbleUp(idx, parentIdx);\n      //   recalculate node idx, parent idx position\n      idx = parentIdx;\n      parentIdx = this.myParentIdx(idx);\n    }\n    return this;\n  }\n\n  //   update val of this key and return this heap\n  //   if there is not any node with this key in this heap return false\n  decreaseKey(key, newVal) {\n    // check whether this key belongs to this heap\n    if (!this.contains(key)) return false;\n    //   get idx of this key\n    let idx = this.idxs[key];\n    //   update node with new val\n    this.values[idx].val = newVal;\n    let parentIdx = this.myParentIdx(idx);\n    if (parentIdx < 0) return this;\n    // bubble-up (while this new node is smaller than its parent)\n    while (this.lessThan(idx, parentIdx)) {\n      this.bubbleUp(idx, parentIdx);\n      //   recalculate node idx, parent idx position\n      idx = parentIdx;\n      parentIdx = this.myParentIdx(idx);\n    }\n    return this;\n  }\n\n  // Remove the root (min),\n  //   put the last element in the top and then rearrange\n  // return the root and the new arrangement\n  dequeue() {\n    // if is empty return undefined\n    if (this.values.length === 0) return undefined;\n    if (this.values.length === 1)\n      return { element: this.values.pop(), heap: this };\n    const min = this.values[0];\n    // replace the root with the last element\n    this.values[0] = this.values.pop();\n    // delete from dict\n    delete this.idxs[min.key];\n    // update idx of the 'new root' in the dict\n    this.idxs[this.values[0].key] = 0;\n    // index of this node we have to rearrange and the idx of its children\n    let idx = 0;\n    let [lChild, rChild] = this.myChildrenIdx(idx);\n    // bubble-down (while any child is smaller than the parent)\n    while (this.lessThan(lChild, idx) || this.lessThan(rChild, idx)) {\n      // update idx and its children\n      idx = this.bubbleDown(idx, lChild, rChild);\n      [lChild, rChild] = this.myChildrenIdx(idx);\n    }\n    return { element: min, heap: this };\n  }\n}\n\nexport default Heap;\n","import Heap from \"../structures/heap\";\nimport {\n  valToIndx,\n  getWeightedPath,\n  manhattan,\n} from \"../helpers/gridPropertiesHelper\";\nimport { pathAnimation, visitedAnimation } from \"../animations\";\n\nconst a = async (grid, start, end, nCols, wRange, alpha) => {\n  const heap = new Heap();\n  // expected value of a random (uniformily) weight :\n  //    sum of all possible values <sum of N first terms of AP> / max value\n  const SCALING_FACTOR = ((wRange + 1) * (wRange / 2)) / wRange;\n  // Initialize distances with Infinity and parents array with null\n  // Distance between any given node to the start node\n  const distances = Array(grid.length * nCols).fill(Infinity);\n  const parents = Array(grid.length * nCols).fill(null);\n  let smallestVal, found;\n  let inspectedNodes = 0;\n  let decrease = false;\n  let nDeq = 0;\n  distances[start.val] = 0;\n  //   add the start node to the heap\n  //   we will use f(n) = alpha * distance + ( 1 - alpha) * Manhattan distance\n  // as val to be minimized in the heap\n  //   f for the start node\n  heap.enqueue(start.val, f(0, start, end, alpha));\n  inspectedNodes++;\n\n  //   while there are elements in this heap\n  while (heap.values.length) {\n    //   get the min value from the heap\n    let s = heap.dequeue().element;\n    nDeq++;\n    // get its vertex\n    smallestVal = s.key;\n    // check if we find the target node\n    if (smallestVal === end.val) {\n      found = true;\n      break;\n    }\n    // convert smallestVal to a Vertex\n    const [r, c] = valToIndx(smallestVal, nCols);\n    const smallest = grid[r][c];\n    // for all neighbour of smallest\n    for (let k in smallest.adjList) {\n      // get the val of the neighbour\n      const neighbour = smallest.adjList[k];\n      // check if is not null => grid border\n      if (neighbour !== null) {\n        const [row, col] = valToIndx(neighbour, nCols);\n        //   neighbour as a vertex\n        let nextVertex = grid[row][col];\n        // calculate Dijkstra's  Greedy Criterium and manhattan distance\n        let d = distances[smallestVal] + smallest.w;\n        let newF = f(d, nextVertex, end, alpha, SCALING_FACTOR);\n        let oldF = f(\n          distances[nextVertex.val],\n          nextVertex,\n          end,\n          alpha,\n          SCALING_FACTOR\n        );\n        //   compare f(d,next,end) with f calculated with last distance storaged\n        if (newF < oldF && !nextVertex.isWall) {\n          //   updating distances and parents\n          distances[nextVertex.val] = d;\n          parents[nextVertex.val] = smallest.val;\n          decrease = heap.decreaseKey(nextVertex.val, newF);\n          if (!decrease) {\n            // enqueue with new priority\n            heap.enqueue(nextVertex.val, newF);\n          }\n          await visitedAnimation(nextVertex.val, start.val, end.val);\n          inspectedNodes++;\n        }\n      }\n    }\n  }\n  if (!found) return;\n  const path = getWeightedPath(parents, start.val, end.val);\n  //   min distance g() found  by A*\n  console.log(`A* Min Distance = ${distances[end.val]}`);\n  //   distance of this path (yellow)\n  console.log(\n    `A* Distance Calculated = ${getPathDistance(path, grid, start, nCols)}`\n  );\n  console.log(`A* inspectedNodes = ${inspectedNodes}`);\n  console.log(`A* Dequeues = ${nDeq}`);\n  console.log(`scaling factor: ${SCALING_FACTOR}`);\n  await pathAnimation(path, start.val);\n};\n\n//   we will use f(n) = (alpha * distance + ( 1 - alpha) * Manhattan distance) * SCALING FACTOR\n//      we use a scaling factor because we compare nodes' weights with distances\n//      weight: [1, wRange] ; while Manhattan d. is calculated in '[nodes distance] units': 1 (for adj nodes)\n// as val to be minimized in the heap\nconst f = (distance, a, b, alpha, sf) => {\n  const g = distance;\n  const h = manhattan(a.row, b.row, a.col, b.col) * sf;\n  const w = g === Infinity && alpha === 0 ? Infinity : alpha * g;\n  const z = (1 - alpha) * h;\n  return w + z;\n};\n\nconst getPathDistance = (path, grid, start, nCols) => {\n  // start and finish nodes are not in the path (yelow animation)\n  let d = start.w;\n  for (let i = 0; i < path.length; i++) {\n    let [r, c] = valToIndx(path[i], nCols);\n    const node = grid[r][c];\n    d += node.w;\n  }\n  return d;\n};\nexport default a;\n","import { makeStyles } from \"@material-ui/core/styles\";\n\nconst styles = makeStyles(() => ({\n  Navbar: {\n    display: \"flex\",\n    alignItems: \"space-around\",\n    justifyContent: \"center\",\n    height: \"8vh\",\n    marginBottom: \"10px\",\n  },\n  title: {\n    display: \"block\",\n  },\n  button: {\n    margin: \"0 6px\",\n    fontSize: \"1rem\",\n    textTransform: \"none\",\n  },\n  slider: {\n    width: \"12vw\",\n    margin: \"0 10px\",\n    display: \"inline-block\",\n    \"& .rc-slider-track\": {\n      backgroundColor: \"transparent\",\n    },\n    \"& .rc-slider-rail\": {\n      height: \"8px\",\n    },\n    \"& .rc-slider-handle:active, .rc-slider-handle:hover, .rc-slider-handle:focus, .rc-slider-handle\": {\n      backgroundColor: \"black\",\n      outline: \"none\",\n      border: \"2px solid black\",\n      boxShadow: \"none\",\n      width: \"13px\",\n      height: \"13px\",\n      marginLeft: \"-7px\",\n      marginTop: \"-3px\",\n    },\n  },\n}));\n\nexport default styles;\n","import React, { useState } from \"react\";\nimport \"rc-slider/assets/index.css\";\nimport bfs from \"./algorithms/bfs\";\nimport dfs from \"./algorithms/dfs\";\nimport a from \"./algorithms/a\";\nimport { clearAnimation, clearPathAnimation } from \"./animations\";\nimport Slider from \"rc-slider\";\nimport AppBar from \"@material-ui/core/AppBar\";\nimport Toolbar from \"@material-ui/core/Toolbar\";\nimport Button from \"@material-ui/core/Button\";\nimport Typography from \"@material-ui/core/Typography\";\nimport styles from \"./NavStyles\";\nimport { valToIndx, getNewMazedGrid } from \"./helpers/gridPropertiesHelper\";\nimport { getInitialGrid } from \"./helpers/initialGridHelper\";\n\nfunction Nav(props) {\n  const {\n    grid,\n    disable,\n    start,\n    end,\n    setGrid,\n    setDisable,\n    nRows,\n    nCols,\n    wRange,\n    isWeighted,\n    setIsWeighted,\n    toggleIsweighted,\n  } = props;\n\n  const clear = () => {\n    clearAnimation(grid, start, end);\n    const n = getInitialGrid(start, end, nRows, nCols, 50);\n    setGrid(n);\n    setIsWeighted(false);\n  };\n\n  const newMaze = async () => {\n    const newGrid = await getNewMazedGrid(grid, 0.33);\n    setGrid(newGrid);\n  };\n\n  const handleClick = async (alg) => {\n    setDisable(true);\n    await alg;\n    setDisable(false);\n  };\n\n  const hanldeSliderChange = () => {\n    if (alpha !== 0 && alpha !== 1) setFName(\"A*\");\n    else {\n      if (alpha === 0) setFName(\"Best Fisrt Search\");\n      if (alpha === 1) setFName(\"Dijkstra\");\n    }\n  };\n\n  const [rowEnd, colEnd] = valToIndx(end, nCols);\n  const [rowStart, colStart] = valToIndx(start, nCols);\n  const [alpha, setAlpha] = useState(0.57);\n  const [fName, setFName] = useState(\"A*\");\n  const changeAlpha = (alpha) => setAlpha(alpha);\n\n  const classes = styles();\n\n  return (\n    <AppBar position=\"static\" color=\"inherit\" className={classes.Navbar}>\n      <Toolbar>\n        <Typography className={classes.title} variant=\"h6\" color=\"inherit\">\n          Pathfinding Visualizer\n        </Typography>\n        <div className={classes.button}>\n          <Button\n            className={classes.button}\n            onClick={() => clear()}\n            disabled={disable}\n          >\n            Clear\n          </Button>\n          <Button\n            className={classes.button}\n            onClick={() => clearPathAnimation(grid)}\n            disabled={disable}\n          >\n            Clear Path\n          </Button>\n          <Button\n            className={classes.button}\n            onClick={() => handleClick(newMaze())}\n            disabled={disable}\n          >\n            Maze\n          </Button>\n          <Button\n            className={classes.button}\n            onClick={() => handleClick(toggleIsweighted())}\n            disabled={disable}\n          >\n            Un/Weighted Grid\n          </Button>\n          <Button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                bfs(grid, grid[rowStart][colStart], grid[rowEnd][colEnd], nCols)\n              )\n            }\n            disabled={isWeighted ? true : disable}\n          >\n            BFS\n          </Button>\n          <Button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                dfs(grid, grid[rowStart][colStart], grid[rowEnd][colEnd], nCols)\n              )\n            }\n            disabled={isWeighted ? true : disable}\n          >\n            DFS\n          </Button>\n          <div className={classes.slider}>\n            <Slider\n              defaultValue={alpha}\n              min={0}\n              max={1}\n              onAfterChange={hanldeSliderChange}\n              onChange={changeAlpha}\n              step={0.01}\n              disabled={!isWeighted ? true : disable}\n            />\n          </div>\n          {!isWeighted ? true : <span>Alpha: {alpha}</span>}\n          <Button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                a(\n                  grid,\n                  grid[rowStart][colStart],\n                  grid[rowEnd][colEnd],\n                  nCols,\n                  wRange,\n                  alpha\n                )\n              )\n            }\n            disabled={!isWeighted ? true : disable}\n          >\n            {fName}\n          </Button>\n          <Button\n            className={classes.button}\n            onClick={() => {\n              window.open(\n                \"https://github.com/LyangHiga/pathfinding-visualizer#instructions\",\n                \"_blank\"\n              );\n            }}\n          >\n            Instructions\n          </Button>\n        </div>\n      </Toolbar>\n    </AppBar>\n  );\n}\n\nexport default Nav;\n","import { useState } from \"react\";\nfunction useToggleState(initialVal = false) {\n  // call useState, \"reserve piece of state\"\n  const [state, setState] = useState(initialVal);\n  const toggle = () => {\n    setState(!state);\n  };\n  // return piece of state AND a function to toggle it\n  return [state, setState, toggle];\n}\nexport default useToggleState;\n","import React, { useState, useEffect } from \"react\";\nimport Node from \"./Node\";\nimport {\n  getNewGridWithWallToggled,\n  getNewGridWitNewStart,\n  getNewGridWitNewFinish,\n  getRowsCols,\n} from \"./helpers/gridPropertiesHelper\";\nimport { getRandomVertex, getInitialGrid } from \"./helpers/initialGridHelper\";\nimport Nav from \"./Nav\";\nimport \"./PathFindingVisualizer.css\";\nimport {\n  wallAnimation,\n  startNodeAnimation,\n  finishNodeAnimation,\n  clearNodeAnimation,\n  sleep,\n} from \"./animations\";\nimport useToggleState from \"./hooks/useToggleState\";\n\nexport default function PathFindingVisualizer() {\n  // fundamental CONSTS\n  const minRows = 20;\n  const minCols = 20;\n  const wRange = 50;\n\n  const [grid, setGrid] = useState([]);\n  const [nRows, setNRows] = useState();\n  const [nCols, setNCols] = useState();\n  const [isWeighted, setIsWeighted, toggleIsweighted] = useToggleState(false);\n  //   disable buttons in nav\n  const [disable, setDisable] = useState(false);\n  const [startVertex, setStarteVertex] = useState(\n    getRandomVertex(minRows, minCols)\n  );\n  const [finishVertex, setFinishVertex] = useState(\n    getRandomVertex(minRows, minCols)\n  );\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [createWall, setCreatWall, toggleCreateWall] = useToggleState(false);\n  const [changeStart, setChangeStart, toggleChangeStart] = useToggleState(\n    false\n  );\n  const [changeFinish, setChangeFinish, toggleChangeFinish] = useToggleState(\n    false\n  );\n\n  //   run only once, similar to Component Did mount\n  useEffect(() => {\n    async function initialGrid() {\n      document.title = \"Pathfinding Visualizer\";\n      const [nRows, nCols] = getRowsCols();\n      setNRows(nRows);\n      setNCols(nCols);\n      const n = getInitialGrid(startVertex, finishVertex, nRows, nCols, wRange);\n      setGrid(n);\n      await sleep(1);\n      startNodeAnimation(startVertex);\n      finishNodeAnimation(finishVertex);\n    }\n    initialGrid();\n  }, []);\n\n  const handleKeyPress = (event) => {\n    switch (event.key) {\n      case \"w\":\n        setChangeStart(false);\n        setChangeFinish(false);\n        return toggleCreateWall();\n      case \"s\":\n        setChangeFinish(false);\n        setCreatWall(false);\n        return toggleChangeStart();\n      case \"f\":\n        setChangeStart(false);\n        setCreatWall(false);\n        return toggleChangeFinish();\n      default:\n        return;\n    }\n  };\n\n  const handleMouseDown = (row, col) => {\n    if (createWall) {\n      wallAnimation(grid[row][col]);\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n      setMouseIsPressed(true);\n    } else if (changeStart) {\n      clearNodeAnimation(startVertex);\n      const newGrid = getNewGridWitNewStart(grid, row, col, startVertex, nCols);\n      setStarteVertex(newGrid[row][col].val);\n      setGrid(newGrid);\n      startNodeAnimation(newGrid[row][col].val);\n      setChangeStart(false);\n    } else if (changeFinish) {\n      clearNodeAnimation(finishVertex);\n      const newGrid = getNewGridWitNewFinish(\n        grid,\n        row,\n        col,\n        finishVertex,\n        nCols\n      );\n      setFinishVertex(newGrid[row][col].val);\n      setGrid(newGrid);\n      finishNodeAnimation(newGrid[row][col].val);\n      setChangeFinish(false);\n    }\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mouseIsPressed || !createWall) return;\n    wallAnimation(grid[row][col]);\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  };\n\n  const handleMouseUp = () => {\n    setMouseIsPressed(false);\n  };\n\n  return (\n    <div onKeyDown={handleKeyPress} tabIndex=\"0\">\n      <Nav\n        grid={grid}\n        setGrid={setGrid}\n        disable={disable}\n        setDisable={setDisable}\n        start={startVertex}\n        end={finishVertex}\n        nRows={nRows}\n        nCols={nCols}\n        wRange={wRange}\n        isWeighted={isWeighted}\n        setIsWeighted={setIsWeighted}\n        toggleIsweighted={toggleIsweighted}\n      />\n      <div className=\"grid\">\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node) => {\n                const { row, col, val, adjList, w } = node;\n                return (\n                  <Node\n                    key={val}\n                    val={val}\n                    col={col}\n                    row={row}\n                    onMouseDown={handleMouseDown}\n                    onMouseEnter={handleMouseEnter}\n                    onMouseUp={handleMouseUp}\n                    adjList={adjList}\n                    w={w}\n                    isWeighted={isWeighted}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n","import React from 'react';\nimport PathFindingVisualizer from './PathFindingVisualizer';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}