{"version":3,"sources":["Node.js","animations.js","helpers/gridPropertiesHelper.js","helpers/initialGridHelper.js","structures/queue.js","algorithms/bfs.js","structures/stack.js","algorithms/dfs.js","structures/heap.js","algorithms/dijkstra.js","algorithms/best-first-search.js","algorithms/a.js","NavStyles.js","Nav.js","hooks/useToggleState.js","PathFindingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","id","val","className","onMouseDown","row","col","onMouseEnter","onMouseUp","isWeighted","w","sleep","m","Promise","r","setTimeout","pathAnimation","path","a","i","length","changingPropAnimation","visitedAnimation","start","end","color","document","getElementById","style","backgroundColor","wallAnimation","v","isStart","isFinish","startNodeAnimation","finishNodeAnimation","clearNodeAnimation","manhattan","b","c","d","Math","abs","valToIndx","nCols","floor","getNewGridWithNewProperty","grid","prop","newGrid","slice","oldNode","oldPropToggled","toggleNodeProperty","node","newNode","getNewGridWithWallToggled","isWall","getNewMazedGrid","eps","random","getPath","parents","dist","push","console","log","reverse","getWeightedPath","getRowsCols","width","window","innerWidth","documentElement","clientWidth","body","height","innerHeight","clientHeight","getRandomVertex","nRows","createNode","finish","adjList","createAdjList","getInitialGrid","wRange","currentRow","this","next","Queue","first","last","size","removed","bfs","visited","q","enQueue","deQueue","key","wVertex","Stack","dfs","result","stack","pop","Heap","values","idxs","k","idx","parentIdx","myParentIdx","lessThan","newKey","undefined","element","heap","min","smallIdx","myChildrenIdx","lChild","rChild","dijkstra","distances","Array","fill","Infinity","inspectedNodes","nDeq","enqueue","s","dequeue","smallestVal","found","smallest","neighbour","nextVertex","decreaseKey","bestFirstSearch","realDistance","alpha","f","newF","oldF","getPathDistance","distance","styles","theme","Navbar","display","alignItems","justifyContent","marginBottom","title","button","margin","cursor","border","fontSize","withStyles","classes","disable","setGrid","setDisable","setIsWeighted","toggleIsweighted","clear","startVal","finishVal","j","clearAnimation","n","newMaze","handleClick","alg","rowEnd","colEnd","rowStart","colStart","AppBar","position","Toolbar","Typography","variant","onClick","disabled","vertex","clearPathAnimation","bestFisrtSearch","open","useToggleState","initialVal","useState","state","setState","toggle","PathFindingVisualizer","setNRows","setNCols","startVertex","setStarteVertex","finishVertex","setFinishVertex","mouseIsPressed","setMouseIsPressed","createWall","setCreatWall","toggleCreateWall","changeStart","setChangeStart","toggleChangeStart","changeFinish","setChangeFinish","toggleChangeFinish","useEffect","initialGrid","handleMouseDown","getNewGridWitNewStart","getNewGridWitNewFinish","handleMouseEnter","handleMouseUp","onKeyDown","event","tabIndex","map","rowIdx","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.68d46391.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.css';\n\nexport default function Node(props) {\n  return (\n    <div\n      id={`node-${props.val}`}\n      className={'node'}\n      onMouseDown={() => props.onMouseDown(props.row, props.col)}\n      onMouseEnter={() => props.onMouseEnter(props.row, props.col)}\n      onMouseUp={() => props.onMouseUp()}\n    >\n      {props.isWeighted ? <span>{props.w}</span> : ''}\n    </div>\n  );\n}\n","export const sleep = (m) => new Promise((r) => setTimeout(r, m));\n\nexport const pathAnimation = async (path) => {\n  for (let i = 0; i < path.length; i++) {\n    await sleep(12);\n    changingPropAnimation(path[i], 'yellow');\n  }\n};\n\nexport const visitedAnimation = async (val, start, end) => {\n  if (val === end) return;\n  if (val === start) return;\n  await sleep(7);\n  changingPropAnimation(val, 'blue');\n};\n\nexport const clearAnimation = (grid, startVal, finishVal) => {\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const v = grid[i][j];\n      changingPropAnimation(v.val, 'white');\n      if (v.val === startVal) {\n        changingPropAnimation(v.val, 'green');\n      }\n      if (v.val === finishVal) {\n        changingPropAnimation(v.val, 'red');\n      }\n    }\n  }\n};\n\nconst changingPropAnimation = (val, color) => {\n  const vertex = document.getElementById(`node-${val}`).style;\n  vertex.backgroundColor = `${color}`;\n};\n\nexport const wallAnimation = async (v) => {\n  if (v.isStart || v.isFinish) return;\n  await sleep(1);\n  changingPropAnimation(v.val, 'black');\n};\n\nexport const startNodeAnimation = (val) => {\n  changingPropAnimation(val, 'green');\n};\n\nexport const finishNodeAnimation = (val) => {\n  changingPropAnimation(val, 'red');\n};\n\nexport const clearNodeAnimation = (val) => {\n  changingPropAnimation(val, 'white');\n};\n\nexport const clearPathAnimation = (grid) => {\n  let vertex;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const v = grid[i][j];\n      vertex = document.getElementById(`node-${v.val}`).style;\n      if (\n        vertex.backgroundColor === 'blue' ||\n        vertex.backgroundColor === 'yellow'\n      ) {\n        clearNodeAnimation(v.val, 'white');\n      }\n    }\n  }\n};\n","import { wallAnimation } from '../animations';\n\n// Node Helpers\n\nexport const manhattan = (a, b, c, d) => {\n  return Math.abs(a - b) + Math.abs(c - d);\n};\n\n// returns {row, col} of a vertex val\nexport const valToIndx = (val, nCols) => {\n  const row = Math.floor(val / nCols);\n  const col = val - row * nCols;\n  return [row, col];\n};\n\n// Grid Helpers\n\nconst getNewGridWithNewProperty = (grid, row, col, prop, val, nCols) => {\n  const newGrid = grid.slice();\n  const [r, c] = valToIndx(val, nCols);\n  const oldNode = newGrid[r][c];\n  const oldPropToggled = toggleNodeProperty(oldNode, prop, false);\n  newGrid[r][c] = oldPropToggled;\n  const node = newGrid[row][col];\n  const newNode = toggleNodeProperty(node, prop, true);\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (wall is created)\nexport const getNewGridWithWallToggled = (grid, row, col) => {\n  if (grid[row][col].isStart || grid[row][col].isFinish) return grid;\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = toggleNodeProperty(node, 'isWall', !node.isWall);\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (new start node)\nexport const getNewGridWitNewStart = (grid, row, col, startVal, nCols) => {\n  const newGrid = getNewGridWithNewProperty(\n    grid,\n    row,\n    col,\n    'isStart',\n    startVal,\n    nCols\n  );\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (new finish point)\nexport const getNewGridWitNewFinish = (grid, row, col, finishVal, nCols) => {\n  const newGrid = getNewGridWithNewProperty(\n    grid,\n    row,\n    col,\n    'isFinish',\n    finishVal,\n    nCols\n  );\n  return newGrid;\n};\n\n// returns a new mazed grid\n// a node has eps prob to become a wall\nexport const getNewMazedGrid = async (grid, eps) => {\n  let newGrid = grid.slice();\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      if (grid[row][col].isStart || grid[row][col].isFinish) {\n        break;\n      }\n      if (Math.random() <= eps) {\n        const node = newGrid[row][col];\n        const newNode = toggleNodeProperty(node, 'isWall', true);\n        newGrid[row][col] = newNode;\n        await wallAnimation(newGrid[row][col]);\n      }\n    }\n  }\n  return newGrid;\n};\n\nconst toggleNodeProperty = (node, prop, val) => {\n  const newNode = {\n    ...node,\n    [prop]: val,\n  };\n  return newNode;\n};\n\n//   building path\nexport const getPath = (parents, end, dist) => {\n  let a = parents[end];\n  let path = [];\n  for (let i = 0; i < dist - 1; i++) {\n    path.push(a);\n    a = parents[a];\n  }\n  console.log(`Min Path: ${path.length + 1} squares`);\n  return path.reverse();\n};\n\n//   building path\nexport const getWeightedPath = (parents, start, end) => {\n  let a = parents[end];\n  let path = [];\n  while (a !== start) {\n    path.push(a);\n    a = parents[a];\n  }\n  return path.reverse();\n};\n\n// return number of rows and cols to display in this screen\nexport const getRowsCols = () => {\n  const width =\n    window.innerWidth ||\n    document.documentElement.clientWidth ||\n    document.body.clientWidth;\n  const height =\n    window.innerHeight ||\n    document.documentElement.clientHeight ||\n    document.body.clientHeight;\n  const nRows = Math.floor(width / 60);\n  const nCols = Math.floor(height / 15);\n  return [nRows, nCols];\n};\n","// import { NUM_COL, NUM_ROW } from '../consts';\n\n// returns a random vertex value\nexport const getRandomVertex = (nRows, nCols) => {\n  return Math.floor(Math.random() * nRows * nCols);\n};\n\nconst createNode = (col, row, start, finish, nRows, nCols, w = 1) => {\n  const val = row * nCols + col;\n  const adjList = createAdjList(val, col, row, nRows, nCols);\n\n  return {\n    col,\n    row,\n    isStart: val === start,\n    isFinish: val === finish,\n    isWall: false,\n    adjList: adjList,\n    val: val,\n    w,\n  };\n};\n\n//         A\n//    B   VAL  D\n//         C\n// returns all neighbours of VAL\nconst createAdjList = (val, col, row, nRows, nCols) => {\n  //   neighbours in a line above\n  // negative numbers arent a node\n  const a = row !== 0 ? val - nCols : null;\n  // neighbours in the same line\n  // check left border\n  const b = col !== 0 ? val - 1 : null;\n  // check right border\n  const d = col !== nCols - 1 ? val + 1 : null;\n  //  neighbours in a line bellow\n  // check overflow\n  const c = row !== nRows - 1 ? val + nCols : null;\n\n  return { a, b, c, d };\n};\n\n// returns the initial Grid\nexport const getInitialGrid = (start, finish, nRows, nCols, wRange = 0) => {\n  const grid = [];\n  for (let row = 0; row < nRows; row++) {\n    const currentRow = [];\n    for (let col = 0; col < nCols; col++) {\n      // get random weight for all edges of this node\n      const w = Math.floor(Math.random() * wRange + 1);\n      currentRow.push(createNode(col, row, start, finish, nRows, nCols, w));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n","// linked list Node\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n// Queue implementation, FIFO, through linked list\nclass Queue {\n  constructor() {\n    this.first = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  // add to the end and return the size of this queue\n  enQueue(val) {\n    let node = new Node(val);\n    if (this.size === 0) {\n      this.first = node;\n      this.last = node;\n    } else {\n      this.last.next = node;\n      this.last = node;\n    }\n    this.size++;\n    return this.size;\n  }\n\n  // remove the first node and return it\n  deQueue() {\n    if (this.size === 0) return null;\n    let removed = this.first;\n    if (this.size === 1) {\n      this.first = null;\n      this.last = null;\n    } else {\n      this.first = removed.next;\n      removed.next = null;\n    }\n    this.size--;\n    return removed;\n  }\n}\n\nexport default Queue;\n","import Queue from '../structures/queue';\nimport { valToIndx, getPath } from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst bfs = async (grid, start, end, nCols) => {\n  let visited = {};\n  let parents = {};\n  let dist = {};\n  let q = new Queue();\n  // add start vertex to the queue\n  q.enQueue(start);\n  // start vertex is already visited\n  visited[start.val] = true;\n  dist[start.val] = 0;\n  parents[start.val] = null;\n  // vertex that will be deQueue\n  let v;\n  while (q.size !== 0) {\n    v = q.deQueue().val;\n    // check if v is the end vertex\n    if (v.val === end.val) {\n      //   we find the target\n      break;\n    }\n    // for every edge of v\n    for (const key in v.adjList) {\n      const w = v.adjList[key];\n      const [row, col] = valToIndx(w, nCols);\n      //   wVertex has all properties while w is wVeterx.val\n      const wVertex = grid[row][col];\n      //   check w is visited, is not null or wall\n      if (visited[w] !== true && w !== null && !wVertex.isWall) {\n        //mark  w as visited\n        visited[w] = true;\n        await visitedAnimation(w, start.val, end.val);\n        //   enQueue vertex w\n        q.enQueue(wVertex);\n        parents[w] = v.val;\n        dist[w] = dist[v.val] + 1;\n      }\n    }\n  }\n  const path = getPath(parents, end.val, dist[end.val]);\n  await pathAnimation(path, start.val);\n};\n\nexport default bfs;\n","// linked list Node\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n// simple implementation using SLL, shift and unshift, here called as push and pop\n// First in Last Out\nclass Stack {\n  constructor() {\n    this.first = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  // add a node at the beginning and return the size of this stack\n  push(val) {\n    let node = new Node(val);\n    if (this.size === 0) {\n      this.first = node;\n      this.last = node;\n    } else {\n      node.next = this.first;\n      this.first = node;\n    }\n    this.size++;\n    return this.size;\n  }\n  // remove the first node and return it\n  pop() {\n    // empty stack\n    if (this.size === 0) return null;\n    let removed = this.first;\n    if (this.size === 1) {\n      this.first = null;\n      this.last = null;\n    } else {\n      this.first = removed.next;\n      removed.next = null;\n    }\n    this.size--;\n    return removed;\n  }\n}\n\nexport default Stack;\n","import Stack from '../structures/stack';\nimport { valToIndx } from '../helpers/gridPropertiesHelper';\nimport { visitedAnimation } from '../animations';\n\nconst dfs = async (grid, start, end, nCols) => {\n  //   const end = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n  //   stack pop order\n  let result = [];\n  let visited = {};\n  let stack = new Stack();\n  // add start vertex to the stack\n  stack.push(start);\n  // start vertex is already visited\n  visited[start.val] = true;\n  let v;\n  while (stack.size !== 0) {\n    // take vertex v from the top of the stack\n    v = stack.pop().val;\n    result.push(v.val);\n    if (v.val === end.val) {\n      //   we find the target\n      break;\n    }\n    // mark w as visited\n    visited[v.val] = true;\n    await visitedAnimation(v.val, start.val, end.val);\n    // for every edge of v\n    for (const key in v.adjList) {\n      const w = v.adjList[key];\n      const [row, col] = valToIndx(w, nCols);\n      //   wVertex has all properties while w is wVeterx.val\n      const wVertex = grid[row][col];\n      //   check w is visited, is not null or wall\n      if (visited[w] !== true && w !== null && !wVertex.isWall) {\n        //   push w vertex\n        stack.push(wVertex);\n        if (w === end.val) {\n          //   we find the target\n          break;\n        }\n      }\n    }\n  }\n};\n\nexport default dfs;\n","class Node {\n  constructor(val, key) {\n    this.val = val;\n    this.key = key;\n  }\n}\n\nclass Heap {\n  constructor() {\n    this.values = [];\n    // dict: val to array idx => you say the val it returns the idx\n    this.idxs = {};\n  }\n\n  // return true if the element from index i is smaller than k idx element\n  lessThan(i, k) {\n    // out of bounds\n    if (i < 0 || k < 0) return false;\n    if (i > this.values.length - 1 || k > this.values.length - 1) return false;\n    let key = this.values[i].key;\n    let parent = this.values[k].key;\n    if (key < parent) return true;\n    return false;\n  }\n\n  //   return the parent's index of the ith node\n  myParentIdx(i) {\n    return Math.floor((i - 1) / 2);\n  }\n\n  //   return the children's index of the ith node\n  myChildrenIdx(i) {\n    // left 2 * i + 1 , right 2 * idx + 2\n    return [2 * i + 1, 2 * i + 2];\n  }\n\n  // insert an element in the next free spot and then sort the Heap if it's needed\n  //   return Heap sorted\n  enqueue(val, key) {\n    let node = new Node(val, key);\n    this.values.push(node);\n    // last position to insert this new node\n    let idx = this.values.length - 1;\n    // add the idx of this val on the dict\n    this.idxs[val] = idx;\n    let parentIdx = this.myParentIdx(idx);\n    // sort (while this new node is smaller than its parent)\n    while (this.lessThan(idx, parentIdx)) {\n      //swap\n      [this.values[idx], this.values[parentIdx]] = [\n        this.values[parentIdx],\n        this.values[idx],\n      ];\n\n      // swap idxs elements in dict val to idx\n      [\n        this.idxs[this.values[idx].val],\n        this.idxs[this.values[parentIdx].val],\n      ] = [\n        this.idxs[this.values[parentIdx].val],\n        this.idxs[this.values[idx].val],\n      ];\n      //   recalculate node idx, parent idx position\n      idx = parentIdx;\n      parentIdx = this.myParentIdx(idx);\n    }\n    return this;\n  }\n\n  //   update key of this node and return this heap sorted\n  //   if there is not any node with this val in this heap return false\n  decreaseKey(val, newKey) {\n    // check whether this val belongs to this heap\n    if (this.values[this.idxs[val]] === undefined) return false;\n    //   get idx of this val\n    let idx = this.idxs[val];\n    //   update node with new key\n    this.values[idx].key = newKey;\n    let parentIdx = this.myParentIdx(idx);\n    if (parentIdx < 0) return this;\n    while (this.lessThan(idx, parentIdx)) {\n      //swap\n      [this.values[idx], this.values[parentIdx]] = [\n        this.values[parentIdx],\n        this.values[idx],\n      ];\n\n      // swap idxs elements in dict val to idx\n      [\n        this.idxs[this.values[idx].val],\n        this.idxs[this.values[parentIdx].val],\n      ] = [\n        this.idxs[this.values[parentIdx].val],\n        this.idxs[this.values[idx].val],\n      ];\n      //   recalculate node idx, parent idx position\n      idx = parentIdx;\n      parentIdx = this.myParentIdx(idx);\n    }\n    return this;\n  }\n\n  // Remove the root (min),\n  //   put the last element in the top and then rearrange\n  // return the root and the new arrangement\n  dequeue() {\n    // if is empty return undefined\n    if (this.values.length === 0) return undefined;\n    if (this.values.length === 1)\n      return { element: this.values.pop(), heap: this };\n    const min = this.values[0];\n    // replace the root with the last element\n    this.values[0] = this.values.pop();\n    // delete from dict\n    delete this.idxs[min.val];\n    // update idx of the 'new root' in the dict\n    this.idxs[this.values[0].val] = 0;\n    // index of this node we have to sort and the idx of its children\n    let idx = 0;\n    let [lChild, rChild] = this.myChildrenIdx(idx);\n    // to keep the smaller\n    let smallIdx;\n    // sort (while any child is smaller than the parent)\n    while (this.lessThan(lChild, idx) || this.lessThan(rChild, idx)) {\n      if (this.lessThan(lChild, rChild)) {\n        smallIdx = lChild;\n      } else if (this.lessThan(rChild, lChild)) {\n        smallIdx = rChild;\n      } else {\n        smallIdx = lChild;\n      }\n      // swap element from idx with greater\n      [this.values[idx], this.values[smallIdx]] = [\n        this.values[smallIdx],\n        this.values[idx],\n      ];\n\n      // swap idxs elements in dict val to idx\n      [\n        this.idxs[this.values[idx].val],\n        this.idxs[this.values[smallIdx].val],\n      ] = [\n        this.idxs[this.values[smallIdx].val],\n        this.idxs[this.values[idx].val],\n      ];\n\n      // update idx and its children\n      idx = smallIdx;\n      [lChild, rChild] = this.myChildrenIdx(idx);\n    }\n    return { element: min, heap: this };\n  }\n}\n\nexport default Heap;\n","import Heap from '../structures/heap';\nimport { valToIndx, getWeightedPath } from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst dijkstra = async (grid, start, end, nCols) => {\n  const heap = new Heap();\n  // Initialize distances with Infinity and parents array with null\n  // Distance between any given node to the start node\n  const distances = Array(grid.length * nCols).fill(Infinity);\n  const parents = Array(grid.length * nCols).fill(null);\n  let smallestVal, found;\n  let inspectedNodes = 0;\n  let nDeq = 0;\n  let decrease = false;\n  distances[start.val] = 0;\n  //   add the start node to the heap\n  heap.enqueue(start.val, 0);\n\n  //   while there are elements in this heap\n  while (heap.values.length) {\n    //   get the min value from the heap\n    let s = heap.dequeue().element;\n    nDeq++;\n\n    // get its vertex\n    smallestVal = s.val;\n    // check if we find the target node\n    if (smallestVal === end.val) {\n      found = true;\n      break;\n    }\n    // convert smallestVal to a Vertex\n    const [r, c] = valToIndx(smallestVal, nCols);\n    const smallest = grid[r][c];\n    // for all neighbour of smallest\n    for (let k in smallest.adjList) {\n      // get the val of the neighbour\n      const neighbour = smallest.adjList[k];\n      // check if is not null => grid border\n      if (neighbour !== null) {\n        const [row, col] = valToIndx(neighbour, nCols);\n        //   neighbour as a vertex\n        let nextVertex = grid[row][col];\n        // calculate Dijkstra's  Greedy Criterium\n        //   distance to smallest (IS short path to it) + smallest to nextVertex edge (W*)\n        // W* : weight of <smallest> edges, all edges from the same node have the same weight in this grid\n        let d = distances[smallestVal] + smallest.w;\n        //   compare distance calculated with last distance storaged\n        if (d < distances[nextVertex.val] && !nextVertex.isWall) {\n          //   updating distances and parents\n          distances[nextVertex.val] = d;\n          parents[nextVertex.val] = smallest.val;\n          decrease = heap.decreaseKey(nextVertex.val, d);\n          if (!decrease) {\n            // enqueue with new priority\n            heap.enqueue(nextVertex.val, d);\n          }\n          await visitedAnimation(nextVertex.val, start.val, end.val);\n          inspectedNodes++;\n        }\n      }\n    }\n  }\n  if (!found) return;\n  const path = getWeightedPath(parents, start.val, end.val);\n  console.log(`dijkstra Min Distance = ${distances[end.val]}`);\n  console.log(`dijkstra inspectedNodes = ${inspectedNodes}`);\n  console.log(`dijkstra dequeues = ${nDeq}`);\n  await pathAnimation(path, start.val);\n};\n\nexport default dijkstra;\n","import Heap from '../structures/heap';\nimport {\n  valToIndx,\n  getWeightedPath,\n  manhattan,\n} from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst bestFirstSearch = async (grid, start, end, nCols) => {\n  const heap = new Heap();\n  // Initialize parents array with null\n  const parents = Array(grid.length * nCols).fill(null);\n  //   the distance between start node and any given node\n  const realDistance = Array(grid.length * nCols).fill(0);\n  let smallestVal, found;\n  let inspectedNodes = 0;\n  let nDeq = 0;\n  let decrease = false;\n  // this time our heap val will be the manhattan distance to the target node\n  heap.enqueue(start.val, manhattan(start.row, end.row, start.col, end.col));\n\n  //   while there are elements in this heap\n  while (heap.values.length) {\n    //   get the min value from the heap\n    let s = heap.dequeue().element;\n    nDeq++;\n    // get its vertex\n    smallestVal = s.val;\n    // check if we find the target node\n    if (smallestVal === end.val) {\n      found = true;\n      break;\n    }\n    // convert smallestVal to a Vertex\n    const [r, c] = valToIndx(smallestVal, nCols);\n    const smallest = grid[r][c];\n    // for all neighbour of smallest\n    for (let k in smallest.adjList) {\n      // get the val of the neighbour\n      const neighbour = smallest.adjList[k];\n      // check if is not null => grid border\n      if (neighbour !== null) {\n        const [row, col] = valToIndx(neighbour, nCols);\n        //   neighbour as a vertex\n        let nextVertex = grid[row][col];\n        //   check if nextVertex is a valid node => not a wall and not visited => realDistance ===0\n        if (!nextVertex.isWall && realDistance[nextVertex.val] === 0) {\n          // calculate manhattan distance from nextVertex to the target node\n          let d = manhattan(row, end.row, col, end.col);\n          //   updating distances and parents\n          parents[nextVertex.val] = smallest.val;\n          // calculate real distance until this node from start node\n          realDistance[nextVertex.val] =\n            realDistance[smallest.val] + smallest.w;\n          decrease = heap.decreaseKey(nextVertex.val, d);\n          if (!decrease) {\n            // enqueue with new priority\n            heap.enqueue(nextVertex.val, d);\n          }\n          inspectedNodes++;\n          await visitedAnimation(nextVertex.val, start.val, end.val);\n        }\n      }\n    }\n  }\n  if (!found) return;\n  const path = getWeightedPath(parents, start.val, end.val);\n  //   distance of this path (yellow)\n  console.log(`bestFirstSearch Distance = ${realDistance[end.val]}`);\n  console.log(`bestFirstSearch inspectedNodes = ${inspectedNodes}`);\n  console.log(`bestFirstSearch dequeues = ${nDeq}`);\n  await pathAnimation(path, start.val);\n};\n\nexport default bestFirstSearch;\n","import Heap from '../structures/heap';\nimport {\n  valToIndx,\n  getWeightedPath,\n  manhattan,\n} from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst a = async (grid, start, end, nCols, alpha) => {\n  const heap = new Heap();\n  // Initialize distances with Infinity and parents array with null\n  // Distance between any given node to the start node\n  const distances = Array(grid.length * nCols).fill(Infinity);\n  const parents = Array(grid.length * nCols).fill(null);\n  let smallestVal, found;\n  let inspectedNodes = 0;\n  let decrease = false;\n  let nDeq = 0;\n  distances[start.val] = 0;\n  //   add the start node to the heap\n  //   we will use f(n) = alpha * distance + ( 1 - alpha) * Manhattan distance\n  // as val to be minimized in the heap\n  //   f for the start node\n  heap.enqueue(start.val, f(0, start, end, alpha));\n  inspectedNodes++;\n\n  //   while there are elements in this heap\n  while (heap.values.length) {\n    //   get the min value from the heap\n    let s = heap.dequeue().element;\n    nDeq++;\n    // get its vertex\n    smallestVal = s.val;\n    // check if we find the target node\n    if (smallestVal === end.val) {\n      found = true;\n      break;\n    }\n    // convert smallestVal to a Vertex\n    const [r, c] = valToIndx(smallestVal, nCols);\n    const smallest = grid[r][c];\n    // for all neighbour of smallest\n    for (let k in smallest.adjList) {\n      // get the val of the neighbour\n      const neighbour = smallest.adjList[k];\n      // check if is not null => grid border\n      if (neighbour !== null) {\n        const [row, col] = valToIndx(neighbour, nCols);\n        //   neighbour as a vertex\n        let nextVertex = grid[row][col];\n        // calculate Dijkstra's  Greedy Criterium and manhattan distance\n        let d = distances[smallestVal] + smallest.w;\n        let newF = f(d, nextVertex, end, alpha);\n        let oldF = f(distances[nextVertex.val], nextVertex, end, alpha);\n        //   compare f(d,next,end) with f calculated with last distance storaged\n        if (newF < oldF && !nextVertex.isWall) {\n          //   updating distances and parents\n          distances[nextVertex.val] = d;\n          parents[nextVertex.val] = smallest.val;\n          decrease = heap.decreaseKey(nextVertex.val, newF);\n          if (!decrease) {\n            // enqueue with new priority\n            heap.enqueue(nextVertex.val, newF);\n          }\n          await visitedAnimation(nextVertex.val, start.val, end.val);\n          inspectedNodes++;\n        }\n      }\n    }\n  }\n  if (!found) return;\n  const path = getWeightedPath(parents, start.val, end.val);\n  //   min distance g() found  by A*\n  console.log(`A* Min Distance = ${distances[end.val]}`);\n  //   distance of this path (yellow)\n  console.log(\n    `A* Distance Calculated = ${getPathDistance(path, grid, start, nCols)}`\n  );\n  console.log(`A* inspectedNodes = ${inspectedNodes}`);\n  console.log(`A* Dequeues = ${nDeq}`);\n  await pathAnimation(path, start.val);\n};\n\n//   we will use f(n) = alpha * distance + ( 1 - alpha) * Manhattan distance\n// as val to be minimized in the heap\nconst f = (distance, a, b, alpha) => {\n  const g = distance;\n  const h = manhattan(a.row, b.row, a.col, b.col);\n  const w = g === Infinity && alpha === 0 ? Infinity : alpha * g;\n  const z = (1 - alpha) * h;\n  return w + z;\n};\n\nconst getPathDistance = (path, grid, start, nCols) => {\n  // start and finish nodes are not in the path (yelow animation)\n  let d = start.w;\n  for (let i = 0; i < path.length; i++) {\n    let [r, c] = valToIndx(path[i], nCols);\n    const node = grid[r][c];\n    d += node.w;\n  }\n  return d;\n};\nexport default a;\n","const styles = (theme) => ({\n  Navbar: {\n    display: 'flex',\n    alignItems: 'space-around',\n    justifyContent: 'center',\n    height: '6vh',\n    marginBottom: '12px',\n  },\n  title: {\n    display: 'block',\n  },\n  button: {\n    margin: '0 10px',\n    cursor: 'pointer',\n    border: 'none',\n    fontSize: '15px',\n  },\n});\n\nexport default styles;\n","import React from 'react';\nimport bfs from './algorithms/bfs';\nimport dfs from './algorithms/dfs';\nimport dijkstra from './algorithms/dijkstra';\nimport bestFisrtSearch from './algorithms/best-first-search';\nimport a from './algorithms/a';\nimport { clearAnimation, clearPathAnimation } from './animations';\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Typography from '@material-ui/core/Typography';\nimport { withStyles } from '@material-ui/core/styles';\nimport styles from './NavStyles';\nimport { valToIndx, getNewMazedGrid } from './helpers/gridPropertiesHelper';\nimport { getInitialGrid } from './helpers/initialGridHelper';\n\nfunction Nav(props) {\n  const {\n    classes,\n    grid,\n    disable,\n    start,\n    end,\n    setGrid,\n    setDisable,\n    nRows,\n    nCols,\n    isWeighted,\n    setIsWeighted,\n    toggleIsweighted,\n  } = props;\n\n  const clear = () => {\n    clearAnimation(grid, start, end);\n    const n = getInitialGrid(start, end, nRows, nCols, 50);\n    setGrid(n);\n    setIsWeighted(false);\n  };\n\n  const newMaze = async () => {\n    const newGrid = await getNewMazedGrid(grid, 0.33);\n    setGrid(newGrid);\n  };\n\n  const handleClick = async (alg) => {\n    setDisable(true);\n    await alg;\n    setDisable(false);\n  };\n  const [rowEnd, colEnd] = valToIndx(end, nCols);\n  const [rowStart, colStart] = valToIndx(start, nCols);\n\n  return (\n    <AppBar position='static' color='inherit' className={classes.Navbar}>\n      <Toolbar>\n        <Typography className={classes.title} variant='h6' color='inherit'>\n          Pathfinding Visualizer\n        </Typography>\n        <div className={classes.button}>\n          <button\n            className={classes.button}\n            onClick={() => clear()}\n            disabled={disable}\n          >\n            Clear\n          </button>\n          <button\n            className={classes.button}\n            onClick={() => clearPathAnimation(grid)}\n            disabled={disable}\n          >\n            Clear Path\n          </button>\n          <button\n            className={classes.button}\n            onClick={() => handleClick(newMaze())}\n            disabled={disable}\n          >\n            Maze\n          </button>\n          <button\n            className={classes.button}\n            onClick={() => handleClick(toggleIsweighted())}\n            disabled={disable}\n          >\n            Un/Weighted Grid\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                bfs(grid, grid[rowStart][colStart], grid[rowEnd][colEnd], nCols)\n              )\n            }\n            disabled={isWeighted ? true : disable}\n          >\n            BFS\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                dfs(grid, grid[rowStart][colStart], grid[rowEnd][colEnd], nCols)\n              )\n            }\n            disabled={isWeighted ? true : disable}\n          >\n            DFS\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                dijkstra(\n                  grid,\n                  grid[rowStart][colStart],\n                  grid[rowEnd][colEnd],\n                  nCols\n                )\n              )\n            }\n            disabled={!isWeighted ? true : disable}\n          >\n            Dijkstra\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                bestFisrtSearch(\n                  grid,\n                  grid[rowStart][colStart],\n                  grid[rowEnd][colEnd],\n                  nCols\n                )\n              )\n            }\n            disabled={!isWeighted ? true : disable}\n          >\n            Best-First Search\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                a(\n                  grid,\n                  grid[rowStart][colStart],\n                  grid[rowEnd][colEnd],\n                  nCols,\n                  0.1\n                )\n              )\n            }\n            disabled={!isWeighted ? true : disable}\n          >\n            A*\n          </button>\n          <button\n            className={classes.button}\n            onClick={() => {\n              window.open(\n                'https://github.com/LyangHiga/pathfinding-visualizer#instructions',\n                '_blank'\n              );\n            }}\n          >\n            Instructions\n          </button>\n        </div>\n      </Toolbar>\n    </AppBar>\n  );\n}\n\nexport default withStyles(styles)(Nav);\n","import { useState } from \"react\";\nfunction useToggleState(initialVal = false) {\n  // call useState, \"reserve piece of state\"\n  const [state, setState] = useState(initialVal);\n  const toggle = () => {\n    setState(!state);\n  };\n  // return piece of state AND a function to toggle it\n  return [state, setState, toggle];\n}\nexport default useToggleState;\n","import React, { useState, useEffect } from 'react';\nimport Node from './Node';\nimport {\n  getNewGridWithWallToggled,\n  getNewGridWitNewStart,\n  getNewGridWitNewFinish,\n  getRowsCols,\n} from './helpers/gridPropertiesHelper';\nimport { getRandomVertex, getInitialGrid } from './helpers/initialGridHelper';\nimport Nav from './Nav';\nimport './PathFindingVisualizer.css';\nimport {\n  wallAnimation,\n  startNodeAnimation,\n  finishNodeAnimation,\n  clearNodeAnimation,\n  sleep,\n} from './animations';\nimport useToggleState from './hooks/useToggleState';\n\nexport default function PathFindingVisualizer() {\n  const minRows = 20;\n  const minCols = 20;\n  const wRange = 50;\n  const [grid, setGrid] = useState([]);\n  const [nRows, setNRows] = useState();\n  const [nCols, setNCols] = useState();\n  const [isWeighted, setIsWeighted, toggleIsweighted] = useToggleState(false);\n  //   disable buttons in nav\n  const [disable, setDisable] = useState(false);\n  const [startVertex, setStarteVertex] = useState(\n    getRandomVertex(minRows, minCols)\n  );\n  const [finishVertex, setFinishVertex] = useState(\n    getRandomVertex(minRows, minCols)\n  );\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [createWall, setCreatWall, toggleCreateWall] = useToggleState(false);\n  const [changeStart, setChangeStart, toggleChangeStart] = useToggleState(\n    false\n  );\n  const [changeFinish, setChangeFinish, toggleChangeFinish] = useToggleState(\n    false\n  );\n\n  //   run only once, similar to Component Did mount\n  useEffect(() => {\n    async function initialGrid() {\n      document.title = 'Pathfinding Visualizer';\n      const [nRows, nCols] = getRowsCols();\n      setNRows(nRows);\n      setNCols(nCols);\n      const n = getInitialGrid(startVertex, finishVertex, nRows, nCols, wRange);\n      setGrid(n);\n      await sleep(1);\n      startNodeAnimation(startVertex);\n      finishNodeAnimation(finishVertex);\n    }\n    initialGrid();\n  }, []);\n\n  const handleKeyPress = (event) => {\n    switch (event.key) {\n      case 'w':\n        setChangeStart(false);\n        setChangeFinish(false);\n        return toggleCreateWall();\n      case 's':\n        setChangeFinish(false);\n        setCreatWall(false);\n        return toggleChangeStart();\n      case 'f':\n        setChangeStart(false);\n        setCreatWall(false);\n        return toggleChangeFinish();\n      default:\n        return;\n    }\n  };\n\n  const handleMouseDown = (row, col) => {\n    if (createWall) {\n      wallAnimation(grid[row][col]);\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n      setMouseIsPressed(true);\n    } else if (changeStart) {\n      clearNodeAnimation(startVertex);\n      const newGrid = getNewGridWitNewStart(grid, row, col, startVertex, nCols);\n      setStarteVertex(newGrid[row][col].val);\n      setGrid(newGrid);\n      startNodeAnimation(newGrid[row][col].val);\n      setChangeStart(false);\n    } else if (changeFinish) {\n      clearNodeAnimation(finishVertex);\n      const newGrid = getNewGridWitNewFinish(\n        grid,\n        row,\n        col,\n        finishVertex,\n        nCols\n      );\n      setFinishVertex(newGrid[row][col].val);\n      setGrid(newGrid);\n      finishNodeAnimation(newGrid[row][col].val);\n      setChangeFinish(false);\n    }\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mouseIsPressed || !createWall) return;\n    wallAnimation(grid[row][col]);\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  };\n\n  const handleMouseUp = () => {\n    setMouseIsPressed(false);\n  };\n\n  return (\n    <div onKeyDown={handleKeyPress} tabIndex='0'>\n      <Nav\n        grid={grid}\n        setGrid={setGrid}\n        disable={disable}\n        setDisable={setDisable}\n        start={startVertex}\n        end={finishVertex}\n        nRows={nRows}\n        nCols={nCols}\n        isWeighted={isWeighted}\n        setIsWeighted={setIsWeighted}\n        toggleIsweighted={toggleIsweighted}\n      />\n      <div className='grid'>\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node) => {\n                const { row, col, val, adjList, w } = node;\n                return (\n                  <Node\n                    key={val}\n                    val={val}\n                    col={col}\n                    row={row}\n                    onMouseDown={handleMouseDown}\n                    onMouseEnter={handleMouseEnter}\n                    onMouseUp={handleMouseUp}\n                    adjList={adjList}\n                    w={w}\n                    isWeighted={isWeighted}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n","import React from 'react';\nimport PathFindingVisualizer from './PathFindingVisualizer';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}