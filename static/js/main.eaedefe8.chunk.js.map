{"version":3,"sources":["Node.js","animations.js","helpers/gridPropertiesHelper.js","helpers/initialGridHelper.js","structures/queue.js","algorithms/bfs.js","structures/stack.js","algorithms/dfs.js","structures/heap.js","algorithms/dijkstra.js","algorithms/best-first-search.js","algorithms/a.js","NavStyles.js","Nav.js","hooks/useToggleState.js","PathFindingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","id","val","className","onMouseDown","row","col","onMouseEnter","onMouseUp","isWeighted","w","sleep","m","Promise","r","setTimeout","pathAnimation","path","a","i","length","changingPropAnimation","visitedAnimation","start","end","color","document","getElementById","style","backgroundColor","wallAnimation","v","isStart","isFinish","startNodeAnimation","finishNodeAnimation","clearNodeAnimation","manhattan","b","c","d","Math","abs","valToIndx","nCols","floor","getNewGridWithNewProperty","grid","prop","newGrid","slice","oldNode","oldPropToggled","toggleNodeProperty","node","newNode","getNewGridWithWallToggled","isWall","getNewMazedGrid","eps","random","getPath","parents","dist","push","console","log","reverse","getWeightedPath","getRowsCols","width","window","innerWidth","documentElement","clientWidth","body","height","innerHeight","clientHeight","getRandomVertex","nRows","createNode","finish","adjList","createAdjList","getInitialGrid","wRange","currentRow","this","next","Queue","first","last","size","removed","bfs","visited","q","enQueue","deQueue","key","wVertex","Stack","dfs","result","stack","pop","Heap","values","idxs","k","idx","parentIdx","lessThan","newVal","undefined","element","heap","min","smallIdx","lChild","rChild","dijkstra","distances","Array","fill","Infinity","inspectedNodes","nDeq","enqueue","s","dequeue","smallestVal","found","smallest","neighbour","nextVertex","decrease","bestFirstSearch","realDistance","alpha","f","newF","oldF","getPathDistance","distance","styles","theme","Navbar","display","alignItems","justifyContent","marginBottom","title","button","margin","cursor","border","fontSize","withStyles","classes","disable","setGrid","setDisable","setIsWeighted","toggleIsweighted","clear","startVal","finishVal","j","clearAnimation","n","newMaze","handleClick","alg","rowEnd","colEnd","rowStart","colStart","AppBar","position","Toolbar","Typography","variant","onClick","disabled","vertex","clearPathAnimation","bestFisrtSearch","useToggleState","initialVal","useState","state","setState","toggle","PathFindingVisualizer","setNRows","setNCols","startVertex","setStarteVertex","finishVertex","setFinishVertex","mouseIsPressed","setMouseIsPressed","createWall","setCreatWall","toggleCreateWall","changeStart","setChangeStart","toggleChangeStart","changeFinish","setChangeFinish","toggleChangeFinish","useEffect","initialGrid","handleMouseDown","getNewGridWitNewStart","getNewGridWitNewFinish","handleMouseEnter","handleMouseUp","onKeyDown","event","tabIndex","map","rowIdx","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.eaedefe8.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.css';\n\nexport default function Node(props) {\n  return (\n    <div\n      id={`node-${props.val}`}\n      className={'node'}\n      onMouseDown={() => props.onMouseDown(props.row, props.col)}\n      onMouseEnter={() => props.onMouseEnter(props.row, props.col)}\n      onMouseUp={() => props.onMouseUp()}\n    >\n      {props.isWeighted ? <span>{props.w}</span> : ''}\n    </div>\n  );\n}\n","export const sleep = (m) => new Promise((r) => setTimeout(r, m));\n\nexport const pathAnimation = async (path) => {\n  for (let i = 0; i < path.length; i++) {\n    await sleep(12);\n    changingPropAnimation(path[i], 'yellow');\n  }\n};\n\nexport const visitedAnimation = async (val, start, end) => {\n  if (val === end) return;\n  if (val === start) return;\n  await sleep(7);\n  changingPropAnimation(val, 'blue');\n};\n\nexport const clearAnimation = (grid, startVal, finishVal) => {\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const v = grid[i][j];\n      changingPropAnimation(v.val, 'white');\n      if (v.val === startVal) {\n        changingPropAnimation(v.val, 'green');\n      }\n      if (v.val === finishVal) {\n        changingPropAnimation(v.val, 'red');\n      }\n    }\n  }\n};\n\nconst changingPropAnimation = (val, color) => {\n  const vertex = document.getElementById(`node-${val}`).style;\n  vertex.backgroundColor = `${color}`;\n};\n\nexport const wallAnimation = async (v) => {\n  if (v.isStart || v.isFinish) return;\n  await sleep(1);\n  changingPropAnimation(v.val, 'black');\n};\n\nexport const startNodeAnimation = (val) => {\n  changingPropAnimation(val, 'green');\n};\n\nexport const finishNodeAnimation = (val) => {\n  changingPropAnimation(val, 'red');\n};\n\nexport const clearNodeAnimation = (val) => {\n  changingPropAnimation(val, 'white');\n};\n\nexport const clearPathAnimation = (grid) => {\n  let vertex;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const v = grid[i][j];\n      vertex = document.getElementById(`node-${v.val}`).style;\n      if (\n        vertex.backgroundColor === 'blue' ||\n        vertex.backgroundColor === 'yellow'\n      ) {\n        clearNodeAnimation(v.val, 'white');\n      }\n    }\n  }\n};\n","import { wallAnimation } from '../animations';\n\n// Node Helpers\n\nexport const manhattan = (a, b, c, d) => {\n  return Math.abs(a - b) + Math.abs(c - d);\n};\n\n// returns {row, col} of a vertex val\nexport const valToIndx = (val, nCols) => {\n  const row = Math.floor(val / nCols);\n  const col = val - row * nCols;\n  return [row, col];\n};\n\n// Grid Helpers\n\nconst getNewGridWithNewProperty = (grid, row, col, prop, val, nCols) => {\n  const newGrid = grid.slice();\n  const [r, c] = valToIndx(val, nCols);\n  const oldNode = newGrid[r][c];\n  const oldPropToggled = toggleNodeProperty(oldNode, prop, false);\n  newGrid[r][c] = oldPropToggled;\n  const node = newGrid[row][col];\n  const newNode = toggleNodeProperty(node, prop, true);\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (wall is created)\nexport const getNewGridWithWallToggled = (grid, row, col) => {\n  if (grid[row][col].isStart || grid[row][col].isFinish) return grid;\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = toggleNodeProperty(node, 'isWall', !node.isWall);\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (new start node)\nexport const getNewGridWitNewStart = (grid, row, col, startVal, nCols) => {\n  const newGrid = getNewGridWithNewProperty(\n    grid,\n    row,\n    col,\n    'isStart',\n    startVal,\n    nCols\n  );\n  return newGrid;\n};\n\n// returns a new grid after a mouse click (new finish point)\nexport const getNewGridWitNewFinish = (grid, row, col, finishVal, nCols) => {\n  const newGrid = getNewGridWithNewProperty(\n    grid,\n    row,\n    col,\n    'isFinish',\n    finishVal,\n    nCols\n  );\n  return newGrid;\n};\n\n// returns a new mazed grid\n// a node has eps prob to become a wall\nexport const getNewMazedGrid = async (grid, eps) => {\n  let newGrid = grid.slice();\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      if (grid[row][col].isStart || grid[row][col].isFinish) {\n        break;\n      }\n      if (Math.random() <= eps) {\n        const node = newGrid[row][col];\n        const newNode = toggleNodeProperty(node, 'isWall', true);\n        newGrid[row][col] = newNode;\n        await wallAnimation(newGrid[row][col]);\n      }\n    }\n  }\n  return newGrid;\n};\n\nconst toggleNodeProperty = (node, prop, val) => {\n  const newNode = {\n    ...node,\n    [prop]: val,\n  };\n  return newNode;\n};\n\n//   building path\nexport const getPath = (parents, end, dist) => {\n  let a = parents[end];\n  let path = [];\n  for (let i = 0; i < dist - 1; i++) {\n    path.push(a);\n    a = parents[a];\n  }\n  console.log(`Min Path: ${path.length + 1} squares`);\n  return path.reverse();\n};\n\n//   building path\nexport const getWeightedPath = (parents, start, end) => {\n  let a = parents[end];\n  let path = [];\n  while (a !== start) {\n    path.push(a);\n    a = parents[a];\n  }\n  return path.reverse();\n};\n\n// return number of rows and cols to display in this screen\nexport const getRowsCols = () => {\n  const width =\n    window.innerWidth ||\n    document.documentElement.clientWidth ||\n    document.body.clientWidth;\n  const height =\n    window.innerHeight ||\n    document.documentElement.clientHeight ||\n    document.body.clientHeight;\n  const nRows = Math.floor(width / 60);\n  const nCols = Math.floor(height / 15);\n  return [nRows, nCols];\n};\n","// import { NUM_COL, NUM_ROW } from '../consts';\n\n// returns a random vertex value\nexport const getRandomVertex = (nRows, nCols) => {\n  return Math.floor(Math.random() * nRows * nCols);\n};\n\nconst createNode = (col, row, start, finish, nRows, nCols, w = 1) => {\n  const val = row * nCols + col;\n  const adjList = createAdjList(val, col, row, nRows, nCols);\n\n  return {\n    col,\n    row,\n    isStart: val === start,\n    isFinish: val === finish,\n    isWall: false,\n    adjList: adjList,\n    val: val,\n    w,\n  };\n};\n\n//         A\n//    B   VAL  D\n//         C\n// returns all neighbours of VAL\nconst createAdjList = (val, col, row, nRows, nCols) => {\n  //   neighbours in a line above\n  // negative numbers arent a node\n  const a = row !== 0 ? val - nCols : null;\n  // neighbours in the same line\n  // check left border\n  const b = col !== 0 ? val - 1 : null;\n  // check right border\n  const d = col !== nCols - 1 ? val + 1 : null;\n  //  neighbours in a line bellow\n  // check overflow\n  const c = row !== nRows - 1 ? val + nCols : null;\n\n  return { a, b, c, d };\n};\n\n// returns the initial Grid\nexport const getInitialGrid = (start, finish, nRows, nCols, wRange = 0) => {\n  const grid = [];\n  for (let row = 0; row < nRows; row++) {\n    const currentRow = [];\n    for (let col = 0; col < nCols; col++) {\n      // get random weight for all edges of this node\n      const w = Math.floor(Math.random() * wRange + 1);\n      currentRow.push(createNode(col, row, start, finish, nRows, nCols, w));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n","// linked list Node\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n// Queue implementation, FIFO, through linked list\nclass Queue {\n  constructor() {\n    this.first = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  // add to the end and return the size of this queue\n  enQueue(val) {\n    let node = new Node(val);\n    if (this.size === 0) {\n      this.first = node;\n      this.last = node;\n    } else {\n      this.last.next = node;\n      this.last = node;\n    }\n    this.size++;\n    return this.size;\n  }\n\n  // remove the first node and return it\n  deQueue() {\n    if (this.size === 0) return null;\n    let removed = this.first;\n    if (this.size === 1) {\n      this.first = null;\n      this.last = null;\n    } else {\n      this.first = removed.next;\n      removed.next = null;\n    }\n    this.size--;\n    return removed;\n  }\n}\n\nexport default Queue;\n","import Queue from '../structures/queue';\nimport { valToIndx, getPath } from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst bfs = async (grid, start, end, nCols) => {\n  let visited = {};\n  let parents = {};\n  let dist = {};\n  let q = new Queue();\n  // add start vertex to the queue\n  q.enQueue(start);\n  // start vertex is already visited\n  visited[start.val] = true;\n  dist[start.val] = 0;\n  parents[start.val] = null;\n  // vertex that will be deQueue\n  let v;\n  while (q.size !== 0) {\n    v = q.deQueue().val;\n    // check if v is the end vertex\n    if (v.val === end.val) {\n      //   we find the target\n      break;\n    }\n    // for every edge of v\n    for (const key in v.adjList) {\n      const w = v.adjList[key];\n      const [row, col] = valToIndx(w, nCols);\n      //   wVertex has all properties while w is wVeterx.val\n      const wVertex = grid[row][col];\n      //   check w is visited, is not null or wall\n      if (visited[w] !== true && w !== null && !wVertex.isWall) {\n        //mark  w as visited\n        visited[w] = true;\n        await visitedAnimation(w, start.val, end.val);\n        //   enQueue vertex w\n        q.enQueue(wVertex);\n        parents[w] = v.val;\n        dist[w] = dist[v.val] + 1;\n      }\n    }\n  }\n  const path = getPath(parents, end.val, dist[end.val]);\n  await pathAnimation(path, start.val);\n};\n\nexport default bfs;\n","// linked list Node\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n// simple implementation using SLL, shift and unshift, here called as push and pop\n// First in Last Out\nclass Stack {\n  constructor() {\n    this.first = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  // add a node at the beginning and return the size of this stack\n  push(val) {\n    let node = new Node(val);\n    if (this.size === 0) {\n      this.first = node;\n      this.last = node;\n    } else {\n      node.next = this.first;\n      this.first = node;\n    }\n    this.size++;\n    return this.size;\n  }\n  // remove the first node and return it\n  pop() {\n    // empty stack\n    if (this.size === 0) return null;\n    let removed = this.first;\n    if (this.size === 1) {\n      this.first = null;\n      this.last = null;\n    } else {\n      this.first = removed.next;\n      removed.next = null;\n    }\n    this.size--;\n    return removed;\n  }\n}\n\nexport default Stack;\n","import Stack from '../structures/stack';\nimport { valToIndx } from '../helpers/gridPropertiesHelper';\nimport { visitedAnimation } from '../animations';\n\nconst dfs = async (grid, start, end, nCols) => {\n  //   const end = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n  //   stack pop order\n  let result = [];\n  let visited = {};\n  let stack = new Stack();\n  // add start vertex to the stack\n  stack.push(start);\n  // start vertex is already visited\n  visited[start.val] = true;\n  let v;\n  while (stack.size !== 0) {\n    // take vertex v from the top of the stack\n    v = stack.pop().val;\n    result.push(v.val);\n    if (v.val === end.val) {\n      //   we find the target\n      break;\n    }\n    // mark w as visited\n    visited[v.val] = true;\n    await visitedAnimation(v.val, start.val, end.val);\n    // for every edge of v\n    for (const key in v.adjList) {\n      const w = v.adjList[key];\n      const [row, col] = valToIndx(w, nCols);\n      //   wVertex has all properties while w is wVeterx.val\n      const wVertex = grid[row][col];\n      //   check w is visited, is not null or wall\n      if (visited[w] !== true && w !== null && !wVertex.isWall) {\n        //   push w vertex\n        stack.push(wVertex);\n        if (w === end.val) {\n          //   we find the target\n          break;\n        }\n      }\n    }\n  }\n};\n\nexport default dfs;\n","class Node {\n  constructor(key, val) {\n    this.key = key;\n    this.val = val;\n  }\n}\n\nclass Heap {\n  constructor() {\n    this.values = [];\n    // dict key to array idx => you say the key it returns the idx\n    this.idxs = {};\n  }\n\n  // return true if the element from index i is less than k idx element\n  lessThan(i, k) {\n    // out of bounds\n    if (i < 0 || k < 0) return false;\n    if (i > this.values.length - 1 || k > this.values.length - 1) return false;\n    let val = this.values[i].val;\n    let parent = this.values[k].val;\n    if (val < parent) return true;\n    return false;\n  }\n\n  // insert an element in the next free spot and then sort the Heap if it's needed\n  //   return Heap sorted\n  enqueue(key, val) {\n    let node = new Node(key, val);\n    this.values.push(node);\n    // last position to insert this new node\n    let idx = this.values.length - 1;\n    // add idx of this key\n    this.idxs[key] = idx;\n    // parent of this new node\n    let parentIdx = Math.floor((idx - 1) / 2);\n    // sort (while this new node is smaller than its parent)\n    while (this.lessThan(idx, parentIdx)) {\n      //swap\n      [this.values[idx], this.values[parentIdx]] = [\n        this.values[parentIdx],\n        this.values[idx],\n      ];\n\n      // swap idxs elements in dict key to idx\n      [\n        this.idxs[this.values[idx].key],\n        this.idxs[this.values[parentIdx].key],\n      ] = [\n        this.idxs[this.values[parentIdx].key],\n        this.idxs[this.values[idx].key],\n      ];\n      //   recalculate node, parent idx position\n      idx = parentIdx;\n      parentIdx = Math.floor((idx - 1) / 2);\n    }\n    return this;\n  }\n\n  //   update node and return this or return false\n  decrease(key, newVal) {\n    //   check if there is a value for this key, in other words\n    // check whether this key belongs to this heap\n    if (this.values[this.idxs[key]] === undefined) return false;\n    //   get idx of this key\n    let idx = this.idxs[key];\n    //   update node with new val\n    this.values[idx].val = newVal;\n    let parentIdx = Math.floor((idx - 1) / 2);\n    if (parentIdx < 0) return this;\n    while (this.lessThan(idx, parentIdx)) {\n      //swap\n      [this.values[idx], this.values[parentIdx]] = [\n        this.values[parentIdx],\n        this.values[idx],\n      ];\n\n      // swap idxs elements in dict key to idx\n      [\n        this.idxs[this.values[idx].key],\n        this.idxs[this.values[parentIdx].key],\n      ] = [\n        this.idxs[this.values[parentIdx].key],\n        this.idxs[this.values[idx].key],\n      ];\n      //   recalculate node, parent idx position\n      idx = parentIdx;\n      parentIdx = Math.floor((idx - 1) / 2);\n    }\n    return this;\n  }\n\n  // Remove the root (min), put the last element in the top and then rearrange\n  // return the root and the new arrangement\n  dequeue() {\n    // if is empty return undefined\n    if (this.values.length === 0) return undefined;\n    if (this.values.length === 1)\n      return { element: this.values.pop(), heap: this };\n    const min = this.values[0];\n    // replace the root with the last element\n    this.values[0] = this.values.pop();\n    // index of this node we have to sort and the idx of its children\n    let idx = 0;\n    let lChild = 2 * idx + 1;\n    let rChild = 2 * idx + 2;\n    // to keep the smaller\n    let smallIdx;\n    // sort (while some child is smaller than the parent)\n    while (this.lessThan(lChild, idx) || this.lessThan(rChild, idx)) {\n      if (this.lessThan(lChild, rChild)) {\n        smallIdx = lChild;\n      } else if (this.lessThan(rChild, lChild)) {\n        smallIdx = rChild;\n      } else {\n        smallIdx = lChild;\n      }\n      // swap element from idx with greater\n      [this.values[idx], this.values[smallIdx]] = [\n        this.values[smallIdx],\n        this.values[idx],\n      ];\n\n      // swap idxs elements in dict key to idx\n      [\n        this.idxs[this.values[idx].key],\n        this.idxs[this.values[smallIdx].key],\n      ] = [\n        this.idxs[this.values[smallIdx].key],\n        this.idxs[this.values[idx].key],\n      ];\n\n      // update idx and its children\n      idx = smallIdx;\n      lChild = 2 * idx + 1;\n      rChild = 2 * idx + 2;\n    }\n    return { element: min, heap: this };\n  }\n}\n\nexport default Heap;\n","import Heap from '../structures/heap';\nimport { valToIndx, getWeightedPath } from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst dijkstra = async (grid, start, end, nCols) => {\n  const heap = new Heap();\n  // Initialize distances with Infinity and parents array with null\n  // Distance between any given node to the start node\n  const distances = Array(grid.length * nCols).fill(Infinity);\n  const parents = Array(grid.length * nCols).fill(null);\n  let smallestVal, found;\n  let inspectedNodes = 0;\n  let nDeq = 0;\n  distances[start.val] = 0;\n  //   add the start node to the heap\n  heap.enqueue(start.val, 0);\n\n  //   while there are elements in this heap\n  while (heap.values.length) {\n    //   get the min value from the heap\n    let s = heap.dequeue().element;\n    nDeq++;\n\n    // get its vertex\n    smallestVal = s.key;\n    // check if we find the target node\n    if (smallestVal === end.val) {\n      found = true;\n      break;\n    }\n    // convert smallestVal to a Vertex\n    const [r, c] = valToIndx(smallestVal, nCols);\n    const smallest = grid[r][c];\n    // for all neighbour of smallest\n    for (let k in smallest.adjList) {\n      // get the val of the neighbour\n      const neighbour = smallest.adjList[k];\n      // check if is not null => grid border\n      if (neighbour !== null) {\n        const [row, col] = valToIndx(neighbour, nCols);\n        //   neighbour as a vertex\n        let nextVertex = grid[row][col];\n        // calculate Dijkstra's  Greedy Criterium\n        //   distance to smallest (IS short path to it) + smallest to nextVertex edge (W*)\n        // W* : weight of <smallest> edges, all edges from the same node have the same weight in this grid\n        let d = distances[smallestVal] + smallest.w;\n        //   compare distance calculated with last distance storaged\n        if (d < distances[nextVertex.val] && !nextVertex.isWall) {\n          //   updating distances and parents\n          distances[nextVertex.val] = d;\n          parents[nextVertex.val] = smallest.val;\n          let decrease = heap.decrease(nextVertex.val, d);\n          if (!decrease) {\n            // enqueue with new priority\n            heap.enqueue(nextVertex.val, d);\n          }\n          await visitedAnimation(nextVertex.val, start.val, end.val);\n          inspectedNodes++;\n        }\n      }\n    }\n  }\n  if (!found) return;\n  const path = getWeightedPath(parents, start.val, end.val);\n  console.log(`dijkstra Min Distance = ${distances[end.val]}`);\n  console.log(`dijkstra inspectedNodes = ${inspectedNodes}`);\n  console.log(`dijkstra dequeues = ${nDeq}`);\n  await pathAnimation(path, start.val);\n};\n\nexport default dijkstra;\n","import Heap from '../structures/heap';\nimport {\n  valToIndx,\n  getWeightedPath,\n  manhattan,\n} from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst bestFirstSearch = async (grid, start, end, nCols) => {\n  const heap = new Heap();\n  // Initialize parents array with null\n  const parents = Array(grid.length * nCols).fill(null);\n  //   the distance between start node and any given node\n  const realDistance = Array(grid.length * nCols).fill(0);\n  let smallestVal, found;\n  let inspectedNodes = 0;\n  let nDeq = 0;\n  // this time our heap val will be the manhattan distance to the target node\n  heap.enqueue(start.val, manhattan(start.row, end.row, start.col, end.col));\n\n  //   while there are elements in this heap\n  while (heap.values.length) {\n    //   get the min value from the heap\n    let s = heap.dequeue().element;\n    nDeq++;\n    // get its vertex\n    smallestVal = s.key;\n    // check if we find the target node\n    if (smallestVal === end.val) {\n      found = true;\n      break;\n    }\n    // convert smallestVal to a Vertex\n    const [r, c] = valToIndx(smallestVal, nCols);\n    const smallest = grid[r][c];\n    // for all neighbour of smallest\n    for (let k in smallest.adjList) {\n      // get the val of the neighbour\n      const neighbour = smallest.adjList[k];\n      // check if is not null => grid border\n      if (neighbour !== null) {\n        const [row, col] = valToIndx(neighbour, nCols);\n        //   neighbour as a vertex\n        let nextVertex = grid[row][col];\n        //   check if nextVertex is a valid node => not a wall and not visited => realDistance ===0\n        if (!nextVertex.isWall && realDistance[nextVertex.val] === 0) {\n          // calculate manhattan distance from nextVertex to the target node\n          let d = manhattan(row, end.row, col, end.col);\n          //   updating distances and parents\n          parents[nextVertex.val] = smallest.val;\n          // calculate real distance until this node from start node\n          realDistance[nextVertex.val] =\n            realDistance[smallest.val] + smallest.w;\n          let decrease = heap.decrease(nextVertex.val, d);\n          if (!decrease) {\n            // enqueue with new priority\n            heap.enqueue(nextVertex.val, d);\n          }\n          inspectedNodes++;\n          await visitedAnimation(nextVertex.val, start.val, end.val);\n        }\n      }\n    }\n  }\n  if (!found) return;\n  const path = getWeightedPath(parents, start.val, end.val);\n  //   distance of this path (yellow)\n  console.log(`bestFirstSearch Real Distance = ${realDistance[end.val]}`);\n  console.log(`bestFirstSearch inspectedNodes = ${inspectedNodes}`);\n  console.log(`bestFirstSearch dequeues = ${nDeq}`);\n  await pathAnimation(path, start.val);\n};\n\nexport default bestFirstSearch;\n","import Heap from '../structures/heap';\nimport {\n  valToIndx,\n  getWeightedPath,\n  manhattan,\n} from '../helpers/gridPropertiesHelper';\nimport { pathAnimation, visitedAnimation } from '../animations';\n\nconst a = async (grid, start, end, nCols, alpha) => {\n  const heap = new Heap();\n  // Initialize distances with Infinity and parents array with null\n  // Distance between any given node to the start node\n  const distances = Array(grid.length * nCols).fill(Infinity);\n  const parents = Array(grid.length * nCols).fill(null);\n  let smallestVal, found;\n  let inspectedNodes = 0;\n  let nDeq = 0;\n  distances[start.val] = 0;\n  //   add the start node to the heap\n  //   we will use f(n) = alpha * distance + ( 1 - alpha) * Manhattan distance\n  // as val to be minimized in the heap\n  //   f for the start node\n  heap.enqueue(start.val, f(0, start, end, alpha));\n  inspectedNodes++;\n\n  //   while there are elements in this heap\n  while (heap.values.length) {\n    //   get the min value from the heap\n    let s = heap.dequeue().element;\n    nDeq++;\n    // get its vertex\n    smallestVal = s.key;\n    // check if we find the target node\n    if (smallestVal === end.val) {\n      found = true;\n      break;\n    }\n    // convert smallestVal to a Vertex\n    const [r, c] = valToIndx(smallestVal, nCols);\n    const smallest = grid[r][c];\n    // for all neighbour of smallest\n    for (let k in smallest.adjList) {\n      // get the val of the neighbour\n      const neighbour = smallest.adjList[k];\n      // check if is not null => grid border\n      if (neighbour !== null) {\n        const [row, col] = valToIndx(neighbour, nCols);\n        //   neighbour as a vertex\n        let nextVertex = grid[row][col];\n        // calculate Dijkstra's  Greedy Criterium and manhattan distance\n        let d = distances[smallestVal] + smallest.w;\n        let newF = f(d, nextVertex, end, alpha);\n        let oldF = f(distances[nextVertex.val], nextVertex, end, alpha);\n        //   compare f(d,next,end) with f calculated with last distance storaged\n        if (newF < oldF && !nextVertex.isWall) {\n          //   updating distances and parents\n          distances[nextVertex.val] = d;\n          parents[nextVertex.val] = smallest.val;\n          let decrease = heap.decrease(nextVertex.val, newF);\n          if (!decrease) {\n            // enqueue with new priority\n            heap.enqueue(nextVertex.val, newF);\n          }\n          await visitedAnimation(nextVertex.val, start.val, end.val);\n          inspectedNodes++;\n        }\n      }\n    }\n  }\n  if (!found) return;\n  const path = getWeightedPath(parents, start.val, end.val);\n  //   min distance g() found  by A*\n  console.log(`A* Min Distance = ${distances[end.val]}`);\n  //   distance of this path (yellow)\n  console.log(\n    `A* Distance Calculated = ${getPathDistance(path, grid, start, nCols)}`\n  );\n  console.log(`A* inspectedNodes = ${inspectedNodes}`);\n  console.log(`A* Dequeues = ${nDeq}`);\n  await pathAnimation(path, start.val);\n};\n\n//   we will use f(n) = alpha * distance + ( 1 - alpha) * Manhattan distance\n// as val to be minimized in the heap\nconst f = (distance, a, b, alpha) => {\n  const g = distance;\n  const h = manhattan(a.row, b.row, a.col, b.col);\n  const w = g === Infinity && alpha === 0 ? Infinity : alpha * g;\n  const z = (1 - alpha) * h;\n  return w + z;\n};\n\nconst getPathDistance = (path, grid, start, nCols) => {\n  // start and finish nodes are not in the path (yelow animation)\n  let d = start.w;\n  for (let i = 0; i < path.length; i++) {\n    let [r, c] = valToIndx(path[i], nCols);\n    const node = grid[r][c];\n    d += node.w;\n  }\n  return d;\n};\nexport default a;\n","const styles = (theme) => ({\n  Navbar: {\n    display: 'flex',\n    alignItems: 'space-around',\n    justifyContent: 'center',\n    height: '6vh',\n    marginBottom: '12px',\n  },\n  title: {\n    display: 'block',\n  },\n  button: {\n    margin: '0 10px',\n    cursor: 'pointer',\n    border: 'none',\n    fontSize: '15px',\n  },\n});\n\nexport default styles;\n","import React from 'react';\nimport bfs from './algorithms/bfs';\nimport dfs from './algorithms/dfs';\nimport dijkstra from './algorithms/dijkstra';\nimport bestFisrtSearch from './algorithms/best-first-search';\nimport a from './algorithms/a';\nimport { clearAnimation, clearPathAnimation } from './animations';\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Typography from '@material-ui/core/Typography';\nimport { withStyles } from '@material-ui/core/styles';\nimport styles from './NavStyles';\nimport { valToIndx, getNewMazedGrid } from './helpers/gridPropertiesHelper';\nimport { getInitialGrid } from './helpers/initialGridHelper';\n\nfunction Nav(props) {\n  const {\n    classes,\n    grid,\n    disable,\n    start,\n    end,\n    setGrid,\n    setDisable,\n    nRows,\n    nCols,\n    isWeighted,\n    setIsWeighted,\n    toggleIsweighted,\n  } = props;\n\n  const clear = () => {\n    clearAnimation(grid, start, end);\n    const n = getInitialGrid(start, end, nRows, nCols, 50);\n    setGrid(n);\n    setIsWeighted(false);\n  };\n\n  const newMaze = async () => {\n    const newGrid = await getNewMazedGrid(grid, 0.33);\n    setGrid(newGrid);\n  };\n\n  const handleClick = async (alg) => {\n    setDisable(true);\n    await alg;\n    setDisable(false);\n  };\n  const [rowEnd, colEnd] = valToIndx(end, nCols);\n  const [rowStart, colStart] = valToIndx(start, nCols);\n\n  return (\n    <AppBar position='static' color='inherit' className={classes.Navbar}>\n      <Toolbar>\n        <Typography className={classes.title} variant='h6' color='inherit'>\n          Pathfinding Visualizer\n        </Typography>\n        <div className={classes.button}>\n          <button\n            className={classes.button}\n            onClick={() => clear()}\n            disabled={disable}\n          >\n            Clear\n          </button>\n          <button\n            className={classes.button}\n            onClick={() => clearPathAnimation(grid)}\n            disabled={disable}\n          >\n            Clear Path\n          </button>\n          <button\n            className={classes.button}\n            onClick={() => handleClick(newMaze())}\n            disabled={disable}\n          >\n            Maze\n          </button>\n          <button\n            className={classes.button}\n            onClick={() => handleClick(toggleIsweighted())}\n            disabled={disable}\n          >\n            Un/Weighted Grid\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                bfs(grid, grid[rowStart][colStart], grid[rowEnd][colEnd], nCols)\n              )\n            }\n            disabled={isWeighted ? true : disable}\n          >\n            BFS\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                dfs(grid, grid[rowStart][colStart], grid[rowEnd][colEnd], nCols)\n              )\n            }\n            disabled={isWeighted ? true : disable}\n          >\n            DFS\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                dijkstra(\n                  grid,\n                  grid[rowStart][colStart],\n                  grid[rowEnd][colEnd],\n                  nCols\n                )\n              )\n            }\n            disabled={!isWeighted ? true : disable}\n          >\n            Dijkstra\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                bestFisrtSearch(\n                  grid,\n                  grid[rowStart][colStart],\n                  grid[rowEnd][colEnd],\n                  nCols\n                )\n              )\n            }\n            disabled={!isWeighted ? true : disable}\n          >\n            Best-First Search\n          </button>\n          <button\n            className={classes.button}\n            onClick={() =>\n              handleClick(\n                a(\n                  grid,\n                  grid[rowStart][colStart],\n                  grid[rowEnd][colEnd],\n                  nCols,\n                  0.1\n                )\n              )\n            }\n            disabled={!isWeighted ? true : disable}\n          >\n            A*\n          </button>\n        </div>\n      </Toolbar>\n    </AppBar>\n  );\n}\n\nexport default withStyles(styles)(Nav);\n","import { useState } from \"react\";\nfunction useToggleState(initialVal = false) {\n  // call useState, \"reserve piece of state\"\n  const [state, setState] = useState(initialVal);\n  const toggle = () => {\n    setState(!state);\n  };\n  // return piece of state AND a function to toggle it\n  return [state, setState, toggle];\n}\nexport default useToggleState;\n","import React, { useState, useEffect } from 'react';\nimport Node from './Node';\nimport {\n  getNewGridWithWallToggled,\n  getNewGridWitNewStart,\n  getNewGridWitNewFinish,\n  getRowsCols,\n} from './helpers/gridPropertiesHelper';\nimport { getRandomVertex, getInitialGrid } from './helpers/initialGridHelper';\nimport Nav from './Nav';\nimport './PathFindingVisualizer.css';\nimport {\n  wallAnimation,\n  startNodeAnimation,\n  finishNodeAnimation,\n  clearNodeAnimation,\n  sleep,\n} from './animations';\nimport useToggleState from './hooks/useToggleState';\n\nexport default function PathFindingVisualizer() {\n  const minRows = 20;\n  const minCols = 20;\n  const wRange = 50;\n  const [grid, setGrid] = useState([]);\n  const [nRows, setNRows] = useState();\n  const [nCols, setNCols] = useState();\n  const [isWeighted, setIsWeighted, toggleIsweighted] = useToggleState(false);\n  //   disable buttons in nav\n  const [disable, setDisable] = useState(false);\n  const [startVertex, setStarteVertex] = useState(\n    getRandomVertex(minRows, minCols)\n  );\n  const [finishVertex, setFinishVertex] = useState(\n    getRandomVertex(minRows, minCols)\n  );\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [createWall, setCreatWall, toggleCreateWall] = useToggleState(false);\n  const [changeStart, setChangeStart, toggleChangeStart] = useToggleState(\n    false\n  );\n  const [changeFinish, setChangeFinish, toggleChangeFinish] = useToggleState(\n    false\n  );\n\n  //   run only once, similar to Component Did mount\n  useEffect(() => {\n    async function initialGrid() {\n      document.title = 'Pathfinding Visualizer';\n      const [nRows, nCols] = getRowsCols();\n      setNRows(nRows);\n      setNCols(nCols);\n      const n = getInitialGrid(startVertex, finishVertex, nRows, nCols, wRange);\n      setGrid(n);\n      await sleep(1);\n      startNodeAnimation(startVertex);\n      finishNodeAnimation(finishVertex);\n    }\n    initialGrid();\n  }, []);\n\n  const handleKeyPress = (event) => {\n    switch (event.key) {\n      case 'w':\n        setChangeStart(false);\n        setChangeFinish(false);\n        return toggleCreateWall();\n      case 's':\n        setChangeFinish(false);\n        setCreatWall(false);\n        return toggleChangeStart();\n      case 'f':\n        setChangeStart(false);\n        setCreatWall(false);\n        return toggleChangeFinish();\n      default:\n        return;\n    }\n  };\n\n  const handleMouseDown = (row, col) => {\n    if (createWall) {\n      wallAnimation(grid[row][col]);\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n      setMouseIsPressed(true);\n    } else if (changeStart) {\n      clearNodeAnimation(startVertex);\n      const newGrid = getNewGridWitNewStart(grid, row, col, startVertex, nCols);\n      setStarteVertex(newGrid[row][col].val);\n      setGrid(newGrid);\n      startNodeAnimation(newGrid[row][col].val);\n      setChangeStart(false);\n    } else if (changeFinish) {\n      clearNodeAnimation(finishVertex);\n      const newGrid = getNewGridWitNewFinish(\n        grid,\n        row,\n        col,\n        finishVertex,\n        nCols\n      );\n      setFinishVertex(newGrid[row][col].val);\n      setGrid(newGrid);\n      finishNodeAnimation(newGrid[row][col].val);\n      setChangeFinish(false);\n    }\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mouseIsPressed || !createWall) return;\n    wallAnimation(grid[row][col]);\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  };\n\n  const handleMouseUp = () => {\n    setMouseIsPressed(false);\n  };\n\n  return (\n    <div onKeyDown={handleKeyPress} tabIndex='0'>\n      <Nav\n        grid={grid}\n        setGrid={setGrid}\n        disable={disable}\n        setDisable={setDisable}\n        start={startVertex}\n        end={finishVertex}\n        nRows={nRows}\n        nCols={nCols}\n        isWeighted={isWeighted}\n        setIsWeighted={setIsWeighted}\n        toggleIsweighted={toggleIsweighted}\n      />\n      <div className='grid'>\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node) => {\n                const { row, col, val, adjList, w } = node;\n                return (\n                  <Node\n                    key={val}\n                    val={val}\n                    col={col}\n                    row={row}\n                    onMouseDown={handleMouseDown}\n                    onMouseEnter={handleMouseEnter}\n                    onMouseUp={handleMouseUp}\n                    adjList={adjList}\n                    w={w}\n                    isWeighted={isWeighted}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n","import React from 'react';\nimport PathFindingVisualizer from './PathFindingVisualizer';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}